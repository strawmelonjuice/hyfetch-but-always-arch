#!/usr/bin/env bash
# vim: noai:ts=4:sw=4:expandtab
# shellcheck source=/dev/null
# shellcheck disable=2009 disable=2153 disable=2154 disable=2243 disable=2244 disable=2317
#
# Neofetch: A command-line system information tool written in bash 3.2+.
# https://github.com/dylanaraps/neofetch
#
# The MIT License (MIT)
#
# Copyright (c) 2015-2021 Dylan Araps
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

version=7.3.11

# Fallback to a value of '5' for shells which support bash
# but do not set the 'BASH_' shell variables (osh).
bash_version=${BASH_VERSINFO[0]:-5}
shopt -s eval_unsafe_arith &>/dev/null

sys_locale=${LANG:-C}
XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-${HOME}/.config}
PATH=$PATH:/usr/xpg4/bin:/usr/sbin:/sbin:/usr/etc:/usr/libexec
reset='\e[0m'
shopt -s nocasematch extglob

# Speed up script by not using unicode.
LC_ALL=C
LANG=C

# Fix issues with gsettings.
[[ -z $GIO_EXTRA_MODULES ]] && export GIO_EXTRA_MODULES=/usr/lib/x86_64-linux-gnu/gio/modules/

# Use sed -r instead of sed -E if using GNU sed.
[[ $(sed --version 2>/dev/null) =~ GNU ]] && gnu_sed=1
sed() {
    if [[ $gnu_sed ]]; then
        command sed "${@//-E/-r}"
    else
        command sed "$@"
    fi
}

# Neofetch default config.
read -rd '' config <<'EOF'
# See this wiki page for more info:
# https://github.com/dylanaraps/neofetch/wiki/Customizing-Info
print_info() {
    info title
    info underline

    info "OS" distro
    info "Host" model
    info "Kernel" kernel
    info "Uptime" uptime
    info "Packages" packages
    info "Shell" shell
    info "Editor" editor
    info "Resolution" resolution
    info "DE" de
    info "WM" wm
    info "WM Theme" wm_theme
    info "Theme" theme
    info "Icons" icons
    info "Cursor" cursor
    info "Terminal" term
    info "Terminal Font" term_font
    info "CPU" cpu
    info "GPU" gpu
    info "Memory" memory
    info "Network" network
    info "Bluetooth" bluetooth
    info "BIOS" bios

    # info "GPU Driver" gpu_driver  # Linux/macOS only
    # info "Disk" disk
    # info "Battery" battery
    # info "Power Adapter" power_adapter # macOS only
    # info "Font" font
    # info "Song" song
    # [[ "$player" ]] && prin "Music Player" "$player"
    # info "Local IP" local_ip
    # info "Public IP" public_ip
    # info "Users" users
    # info "Locale" locale  # This only works on glibc systems.

    # info "Java" java_ver
    # info "Python" python_ver
    # info "Node" node_ver

    info cols
}

# Title


# Hide/Show Fully qualified domain name.
#
# Default:  'off'
# Values:   'on', 'off'
# Flag:     --title_fqdn
title_fqdn="off"


# Kernel


# Shorten the output of the kernel function.
#
# Default:  'on'
# Values:   'on', 'off'
# Flag:     --kernel_shorthand
# Supports: Everything except *BSDs (except PacBSD and PC-BSD)
#
# Example:
# on:  '4.8.9-1-ARCH'
# off: 'Linux 4.8.9-1-ARCH'
kernel_shorthand="on"


# Distro


# Shorten the output of the distro function
#
# Default:  'off'
# Values:   'on', 'tiny', 'off'
# Flag:     --distro_shorthand
# Supports: Everything except Windows and Haiku
distro_shorthand="off"

# Show/Hide OS Architecture.
# Show 'x86_64', 'x86' and etc in 'Distro:' output.
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --os_arch
#
# Example:
# on:  'Arch Linux x86_64'
# off: 'Arch Linux'
os_arch="on"


# Uptime


# Shorten the output of the uptime function
#
# Default: 'on'
# Values:  'on', 'tiny', 'off'
# Flag:    --uptime_shorthand
#
# Example:
# on:   '2 days, 10 hours, 3 mins'
# tiny: '2d 10h 3m'
# off:  '2 days, 10 hours, 3 minutes'
uptime_shorthand="on"


# Memory


# Show memory percentage in output.
#
# Default: 'off'
# Values:  'on', 'off'
# Flag:    --memory_percent
#
# Example:
# on:   '1801MiB / 7881MiB (22%)'
# off:  '1801MiB / 7881MiB'
memory_percent="on"

# Change memory output unit.
#
# Default: 'mib'
# Values:  'kib', 'mib', 'gib', 'tib'
# Flag:    --memory_unit
#
# Example:
# kib  '1020928KiB / 7117824KiB'
# mib  '1042MiB / 6951MiB'
# gib: ' 0.98GiB / 6.79GiB'
memory_unit="gib"

# Change memory output precision.
#
# Default: '2'
# Values: integer ≥ 0
# Flag:    --memory_precision
mem_precision=2

# Packages


# Show/Hide Package Manager names.
#
# Default: 'tiny'
# Values:  'on', 'tiny' 'off'
# Flag:    --package_managers
#
# Example:
# on:   '998 (pacman), 8 (flatpak), 4 (snap)'
# tiny: '908 (pacman, flatpak, snap)'
# off:  '908'
package_managers="on"


# Show separate user and system packages for supported package managers
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --package_separate
#
# Example:
# on:  '8 packages (flatpak-system), 9 packages (flatpak-user)'
# off: '17 packages (flatpak)'
package_separate="on"

# Reduce output of packages list by not showing programming language package managers or Steam games
#
# Flag:    --package_minimal
#
# Example:
# default:  'Packages: 1 (npm), 991 (emerge), 3 (steam), 23 (flatpak-system)'
# minimal: 'Packages: 991 (emerge), 23 (flatpak-system)'
package_minimal=""


# Shell


# Show the path to $SHELL
#
# Default: 'off'
# Values:  'on', 'off'
# Flag:    --shell_path
#
# Example:
# on:  '/bin/bash'
# off: 'bash'
shell_path="off"

# Show $SHELL version
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --shell_version
#
# Example:
# on:  'bash 4.4.5'
# off: 'bash'
shell_version="on"


# Editor


# Show path to $EDITOR
#
# Default: 'off'
# Values:  'on', 'off'
# Flag:    --editor_path
#
# Example:
# on:  '/opt/bin/vim'
# off: 'vim'
editor_path="off"

# Show $EDITOR version
#
# Default:  'on'
# Values:   'on', 'off'
# Flag:     '--editor_version'
#
# Example:
# on:  'vim 9.0'
# off: 'vim'
editor_version="on"


# CPU


# CPU speed type
#
# Default: 'bios_limit'
# Values: 'scaling_cur_freq', 'scaling_min_freq', 'scaling_max_freq', 'bios_limit'.
# Flag:    --speed_type
# Supports: Linux with 'cpufreq'
# NOTE: Any file in '/sys/devices/system/cpu/cpu0/cpufreq' can be used as a value.
speed_type="bios_limit"

# CPU speed shorthand
#
# Default: 'off'
# Values: 'on', 'off'.
# Flag:    --speed_shorthand
# NOTE: This flag is not supported in systems with CPU speed less than 1 GHz
#
# Example:
# on:    'i7-6500U (4) @ 3.1GHz'
# off:   'i7-6500U (4) @ 3.100GHz'
speed_shorthand="on"

# Enable/Disable CPU brand in output.
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --cpu_brand
#
# Example:
# on:   'Intel i7-6500U'
# off:  'i7-6500U (4)'
cpu_brand="on"

# CPU Speed
# Hide/Show CPU speed.
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --cpu_speed
#
# Example:
# on:  'Intel i7-6500U (4) @ 3.1GHz'
# off: 'Intel i7-6500U (4)'
cpu_speed="on"

# CPU Cores
# Display CPU cores in output
#
# Default: 'logical'
# Values:  'logical', 'physical', 'off'
# Flag:    --cpu_cores
# Support: 'physical' doesn't work on BSD.
#
# Example:
# logical:  'Intel i7-6500U (4) @ 3.1GHz' (All virtual cores)
# physical: 'Intel i7-6500U (2) @ 3.1GHz' (All physical cores)
# off:      'Intel i7-6500U @ 3.1GHz'
cpu_cores="logical"

# CPU Temperature
# Hide/Show CPU temperature.
# Note the temperature is added to the regular CPU function.
#
# Default: 'off'
# Values:  'C', 'F', 'off'
# Flag:    --cpu_temp
# Supports: Linux, BSD
# NOTE: For FreeBSD and NetBSD-based systems, you'll need to enable
#       coretemp kernel module. This only supports newer Intel processors.
#
# Example:
# C:   'Intel i7-6500U (4) @ 3.1GHz [27.2°C]'
# F:   'Intel i7-6500U (4) @ 3.1GHz [82.0°F]'
# off: 'Intel i7-6500U (4) @ 3.1GHz'
cpu_temp="off"


# GPU


# Enable/Disable GPU Brand
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --gpu_brand
#
# Example:
# on:  'AMD HD 7950'
# off: 'HD 7950'
gpu_brand="on"

# Which GPU to display
#
# Default: 'all'
# Values:  'all', 'dedicated', 'integrated'
# Flag:    --gpu_type
# Supports: Linux
#
# Example:
# all:
#   GPU1: AMD HD 7950
#   GPU2: Intel Integrated Graphics
#
# dedicated:
#   GPU1: AMD HD 7950
#
# integrated:
#   GPU1: Intel Integrated Graphics
gpu_type="all"


# Resolution


# Display refresh rate next to each monitor
# Default: 'off'
# Values:  'on', 'off'
# Flag:    --refresh_rate
# Supports: Doesn't work on Windows.
#
# Example:
# on:  '1920x1080 @ 60Hz'
# off: '1920x1080'
refresh_rate="on"


# Gtk Theme / Icons / Font


# Shorten output of GTK Theme / Icons / Font
#
# Default: 'off'
# Values:  'on', 'off'
# Flag:    --gtk_shorthand
#
# Example:
# on:  'Numix, Adwaita'
# off: 'Numix [GTK2], Adwaita [GTK3]'
gtk_shorthand="off"


# Enable/Disable gtk2 Theme / Icons / Font
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --gtk2
#
# Example:
# on:  'Numix [GTK2], Adwaita [GTK3]'
# off: 'Adwaita [GTK3]'
gtk2="on"

# Enable/Disable gtk3 Theme / Icons / Font
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --gtk3
#
# Example:
# on:  'Numix [GTK2], Adwaita [GTK3]'
# off: 'Numix [GTK2]'
gtk3="on"

# Enable/Disable Qt Theme / Icons / Font
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --qt
#
# Example:
# on:  'Breeze [Qt], Arc [GTK3]'
# off: 'Arc [GTK3]'
qt="on"

# IP Address


# Website to ping for the public IP
#
# Default: 'http://ident.me'
# Values:  'url'
# Flag:    --ip_host
public_ip_host="http://ident.me"

# Public IP timeout.
#
# Default: '2'
# Values:  'int'
# Flag:    --ip_timeout
public_ip_timeout=2

# Local IP interface
#
# Default: 'auto' (interface of default route)
# Values:  'auto', 'en0', 'en1'
# Flag:    --ip_interface
local_ip_interface=('auto')


# Desktop Environment


# Show Desktop Environment version
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --de_version
de_version="on"


# Disk


# Which disks to display.
# The values can be any /dev/sdXX, mount point or directory.
# NOTE: By default we only show the disk info for '/'.
#
# Default: '/'
# Values:  '/', '/dev/sdXX', '/path/to/drive'.
# Flag:    --disk_show
#
# Example:
# disk_show=('/' '/dev/sdb1'):
#      'Disk (/): 74G / 118G (66%)'
#      'Disk (/mnt/Videos): 823G / 893G (93%)'
#
# disk_show=('/'):
#      'Disk (/): 74G / 118G (66%)'
#
disk_show=('/')

# Disk subtitle.
# What to append to the Disk subtitle.
#
# Default: 'mount'
# Values:  'mount', 'name', 'dir', 'none'
# Flag:    --disk_subtitle
#
# Example:
# name:   'Disk (/dev/sda1): 74G / 118G (66%)'
#         'Disk (/dev/sdb2): 74G / 118G (66%)'
#
# mount:  'Disk (/): 74G / 118G (66%)'
#         'Disk (/mnt/Local Disk): 74G / 118G (66%)'
#         'Disk (/mnt/Videos): 74G / 118G (66%)'
#
# dir:    'Disk (/): 74G / 118G (66%)'
#         'Disk (Local Disk): 74G / 118G (66%)'
#         'Disk (Videos): 74G / 118G (66%)'
#
# none:   'Disk: 74G / 118G (66%)'
#         'Disk: 74G / 118G (66%)'
#         'Disk: 74G / 118G (66%)'
disk_subtitle="mount"

# Disk percent.
# Show/Hide disk percent.
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --disk_percent
#
# Example:
# on:  'Disk (/): 74G / 118G (66%)'
# off: 'Disk (/): 74G / 118G'
disk_percent="on"


# Song


# Manually specify a music player.
#
# Default: 'auto'
# Values:  'auto', 'player-name'
# Flag:    --music_player
#
# Available values for 'player-name':
#
# amarok
# audacious
# banshee
# bluemindo
# cider
# clementine
# cmus
# deadbeef
# deepin-music
# dragon
# elisa
# exaile
# gnome-music
# gmusicbrowser
# gogglesmm
# guayadeque
# io.elementary.music
# iTunes
# Music
# juk
# lollypop
# MellowPlayer
# mocp
# mopidy
# mpd
# muine
# netease-cloud-music
# olivia
# playerctl
# pogo
# pragha
# qmmp
# quodlibet
# rhythmbox
# sayonara
# smplayer
# spotify
# strawberry
# tauonmb
# tomahawk
# vlc
# xmms2d
# xnoise
# yarock
music_player="auto"

# Format to display song information.
#
# Default: '%artist% - %album% - %title%'
# Values:  '%artist%', '%album%', '%title%'
# Flag:    --song_format
#
# Example:
# default: 'Song: Jet - Get Born - Sgt Major'
song_format="%artist% - %album% - %title%"

# Print the Artist, Album and Title on separate lines
#
# Default: 'off'
# Values:  'on', 'off'
# Flag:    --song_shorthand
#
# Example:
# on:  'Artist: The Fratellis'
#      'Album: Costello Music'
#      'Song: Chelsea Dagger'
#
# off: 'Song: The Fratellis - Costello Music - Chelsea Dagger'
song_shorthand="off"

# 'mpc' arguments (specify a host, password etc).
#
# Default:  ''
# Example: mpc_args=(-h HOST -P PASSWORD)
mpc_args=()


# Text Colors


# Text Colors
#
# Default:  'distro'
# Values:   'distro', 'num' 'num' 'num' 'num' 'num' 'num'
# Flag:     --colors
#
# Each number represents a different part of the text in
# this order: 'title', '@', 'underline', 'subtitle', 'colon', 'info'
#
# Example:
# colors=(distro)      - Text is colored based on Distro colors.
# colors=(4 6 1 8 8 6) - Text is colored in the order above.
colors=(distro)


# Text Options


# Toggle bold text
#
# Default:  'on'
# Values:   'on', 'off'
# Flag:     --bold
bold="on"

# Enable/Disable Underline
#
# Default:  'on'
# Values:   'on', 'off'
# Flag:     --underline
underline_enabled="on"

# Underline character
#
# Default:  '-'
# Values:   'string'
# Flag:     --underline_char
underline_char="-"


# Info Separator
# Replace the default separator with the specified string.
#
# Default:  ':'
# Flag:     --separator
#
# Example:
# separator="->":   'Shell-> bash'
# separator=" =":   'WM = dwm'
separator=":"


# Color Blocks


# Color block range
# The range of colors to print.
#
# Default:  '0', '15'
# Values:   'num'
# Flag:     --block_range
#
# Example:
#
# Display colors 0-7 in the blocks.  (8 colors)
# neofetch --block_range 0 7
#
# Display colors 0-15 in the blocks. (16 colors)
# neofetch --block_range 0 15
block_range=(0 15)

# Toggle color blocks
#
# Default:  'on'
# Values:   'on', 'off'
# Flag:     --color_blocks
color_blocks="on"

# Color block width in spaces
#
# Default:  '3'
# Values:   'num'
# Flag:     --block_width
block_width=3

# Color block height in lines
#
# Default:  '1'
# Values:   'num'
# Flag:     --block_height
block_height=1

# Color Alignment
#
# Default: 'auto'
# Values: 'auto', 'num'
# Flag: --col_offset
#
# Number specifies how far from the left side of the terminal (in spaces) to
# begin printing the columns, in case you want to e.g. center them under your
# text.
# Example:
# col_offset="auto" - Default behavior of neofetch
# col_offset=7      - Leave 7 spaces then print the colors
col_offset="auto"

# Progress Bars


# Bar characters
#
# Default:  '-', '='
# Values:   'string', 'string'
# Flag:     --bar_char
#
# Example:
# neofetch --bar_char 'elapsed' 'total'
# neofetch --bar_char '-' '='
bar_char_elapsed="-"
bar_char_total="="

# Toggle Bar border
#
# Default:  'on'
# Values:   'on', 'off'
# Flag:     --bar_border
bar_border="on"

# Progress bar length in spaces
# Number of chars long to make the progress bars.
#
# Default:  '15'
# Values:   'num'
# Flag:     --bar_length
bar_length=15

# Progress bar colors
# When set to distro, uses your distro's logo colors.
#
# Default:  'distro', 'distro'
# Values:   'distro', 'num'
# Flag:     --bar_colors
#
# Example:
# neofetch --bar_colors 3 4
# neofetch --bar_colors distro 5
bar_color_elapsed="distro"
bar_color_total="distro"


# Info display
# Display a bar with the info.
#
# Default: 'off'
# Values:  'bar', 'infobar', 'barinfo', 'off'
# Flags:   --memory_display
#          --battery_display
#          --disk_display
#
# Example:
# bar:     '[---=======]'
# infobar: 'info [---=======]'
# barinfo: '[---=======] info'
# off:     'info'
memory_display="off"
battery_display="off"
disk_display="off"


# Backend Settings


# Image backend.
#
# Default:  'ascii'
# Values:   'ascii', 'caca', 'catimg', 'chafa', 'jp2a', 'iterm2', 'off',
#           'pot', 'termpix', 'pixterm', 'tycat', 'w3m', 'kitty', 'ueberzug',
#           'viu'

# Flag:     --backend
image_backend="ascii"

# Image Source
#
# Which image or ascii file to display.
#
# Default:  'auto'
# Values:   'auto', 'ascii', 'wallpaper', '/path/to/img', '/path/to/ascii', '/path/to/dir/'
#           'command output (neofetch --ascii "$(fortune | cowsay -W 30)")'
# Flag:     --source
#
# NOTE: 'auto' will pick the best image source for whatever image backend is used.
#       In ascii mode, distro ascii art will be used and in an image mode, your
#       wallpaper will be used.
image_source="auto"


# Ascii Options


# Ascii distro
# Which distro's ascii art to display.
#
# Default: 'auto'
# Values:  'auto', 'distro_name'
# Flag:    --ascii_distro
#
# NOTE: Adélie, aerOS, Afterglow, AIX, AlmaLinux, Alpine, Alter, Amazon, AmogOS, Anarchy, Android,
# Antergos, antiX, AOSC OS, Aperio GNU/Linux, Aperture, Apricity, Arch, ArchBox, Archcraft,
# archcraft_ascii, archcraft_minimal, ARCHlabs, ArchMerge, ArchStrike, ArcoLinux, ArseLinux, Artix,
# Arya, Asahi, AsteroidOS, astOS, Astra Linux, Athena, azos, Bedrock, BigLinux, Bitrig, BlackArch,
# BlackMesa, blackPanther, BLAG, BlankOn, BlueLight, Bodhi, bonsai, BSD, BunsenLabs, CachyOS, Calculate,
# CalinixOS, Carbs, CBL-Mariner, CelOS, Center, CentOS, Chakra, ChaletOS, Chapeau, Chimera, ChonkySealOS,
# Chrom, Cleanjaro, Clear Linux OS, ClearOS, Clover, Cobalt, Condres, Container Linux by CoreOS,
# CRUX, Crystal Linux, Cucumber, CutefishOS, CuteOS, CyberOS, dahlia, DarkOs, Darwin, Debian,
# Deepin, DesaOS, Devuan, DietPi, digital UNIX, DracOS, DragonFly, Drauger, Droidian, Elementary,
# Elive, EncryptOS, EndeavourOS, Endless, Enso, EuroLinux, EvolutionOS, eweOS, Exherbo, Exodia Predator OS,
# Fedora, FemboyOS, Feren, Finnix, Floflis, FreeBSD, FreeMiNT, Frugalware, Funtoo, Furreto, GalliumOS,
# Garuda, Gentoo, GhostBSD, glaucus, gNewSense, GNOME, GNU, GoboLinux, GrapheneOS, Grombyang, Guix,
# Haiku, HamoniKR, HarDClanZ, Hash, Huayra, Hybrid, HydroOS, Hyperbola, iglunix, instantOS, Interix,
# IRIX, Ironclad, Itc, januslinux, Kaisen, Kali, KaOS, KDE, Kibojoe, Kogaion, Korora, KrassOS,
# KSLinux, Kubuntu, LainOS, LangitKetujuh, LaxerOS, LEDE, LibreELEC, Linspire, Linux, Linux Lite,
# Linux Mint, Linux Mint Old, Live Raizo, LMDE, Lubuntu, Lunar, mac, Mageia, MagpieOS, MainsailOS,
# Mandriva, Manjaro, MassOS, MatuusOS, Maui, Meowix, Mer, Minix, MIRACLE LINUX, MX, Namib, NekOS,
# Neptune, NetBSD, Netrunner, Nitrux, NixOS, Nobara, NomadBSD, Nurunner, NuTyX, Obarun, OBRevenge,
# OmniOS, Open Source Media Center, OpenBSD, openEuler, OpenIndiana, openKylin, openmamba,
# OpenMandriva, OpenStage, openSUSE, openSUSE Leap, openSUSE Tumbleweed, OPNsense, Oracle, orchid,
# OS Elbrus, PacBSD, Panwah, Parabola, parch, Pardus, Parrot, Parsix, PCBSD, PCLinuxOS, pearOS,
# Pengwin, Pentoo, Peppermint, Peropesis, phyOS, PikaOS, Pisi, PNM Linux, Pop!_OS, Porteus,
# PostMarketOS, Profelis SambaBOX, Proxmox, PuffOS, Puppy, PureOS, Q4OS, Qubes, Qubyt, Quibian,
# Radix, Raspbian, ravynOS, Reborn OS, Red Star, Redcore, Redhat, Refracted Devuan, Regata,
# Regolith, RhaymOS, rocky, Rosa, Sabayon, sabotage, Sailfish, SalentOS, Salient OS, Salix, Sasanqua,
# Scientific, semc, Septor, Serene, SharkLinux, ShastraOS, Siduction, SkiffOS, Slackel, Slackware,
# SliTaz, SmartOS, Soda, Solus, Source Mage, Sparky, Star, SteamOS, Stock Linux, Sulin, SunOS,
# SwagArch, t2, Tails, TeArch, TorizonCore, Trisquel, Twister, Ubuntu, Ubuntu Budgie, Ubuntu
# Cinnamon, Ubuntu Kylin, Ubuntu MATE, Ubuntu Studio, Ubuntu Sway, Ubuntu Touch, Ubuntu-GNOME,
# ubuntu_old02, Ultramarine Linux, unicodearch, Univalent, Univention, Uos, UrukOS, uwuntu, Vanilla,
# Venom, VNux, Void, VzLinux, wii-linux-ngx, Windows, Windows 10, Windows 11, Windows95, Wrt, Xenia,
# Xenia2, XFerience, Xray_OS, Xubuntu, yiffOS, Zorin have ascii logos.

# NOTE: arch, dragonfly, Fedora, LangitKetujuh, nixos, redhat, Ubuntu have 'old' logo variants, use
# {distro}_old to use them.

# NOTE: alpine, android, arch, arcolinux, artix, CalinixOS, centos, cleanjaro, crux, debian,
# dragonfly, elementary, endeavouros, fedora, freebsd, garuda, gentoo, guix, haiku, hyperbola, kali,
# Linux, linuxlite, linuxmint, mac, mageia, MainsailOS, manjaro, mx, netbsd, nixos, openbsd,
# opensuse, orchid, parabola, popos, postmarketos, pureos, Raspbian, rocky, slackware, sunos,
# ubuntu, venom, void have 'small' logo variants, use {distro}_small to use them.
ascii_distro="auto"

# Ascii Colors
#
# Default:  'distro'
# Values:   'distro', 'num' 'num' 'num' 'num' 'num' 'num'
# Flag:     --ascii_colors
#
# Example:
# ascii_colors=(distro)      - Ascii is colored based on Distro colors.
# ascii_colors=(4 6 1 8 8 6) - Ascii is colored using these colors.
ascii_colors=(distro)

# Bold ascii logo
# Whether or not to bold the ascii logo.
#
# Default: 'on'
# Values:  'on', 'off'
# Flag:    --ascii_bold
ascii_bold="on"


# Image Options


# Image loop
# Setting this to on will make neofetch redraw the image constantly until
# Ctrl+C is pressed. This fixes display issues in some terminal emulators.
#
# Default:  'off'
# Values:   'on', 'off'
# Flag:     --loop
image_loop="off"

# Thumbnail directory
#
# Default: '~/.cache/thumbnails/neofetch'
# Values:  'dir'
thumbnail_dir="${XDG_CACHE_HOME:-${HOME}/.cache}/thumbnails/neofetch"

# Crop mode
#
# Default:  'normal'
# Values:   'normal', 'fit', 'fill'
# Flag:     --crop_mode
#
# See this wiki page to learn about the fit and fill options.
# https://github.com/dylanaraps/neofetch/wiki/What-is-Waifu-Crop%3F
crop_mode="normal"

# Crop offset
# Note: Only affects 'normal' crop mode.
#
# Default:  'center'
# Values:   'northwest', 'north', 'northeast', 'west', 'center'
#           'east', 'southwest', 'south', 'southeast'
# Flag:     --crop_offset
crop_offset="center"

# Image size
# The image is half the terminal width by default.
#
# Default: 'auto'
# Values:  'auto', '00px', '00%', 'none'
# Flags:   --image_size
#          --size
image_size="auto"

# Catimg block size.
# Control the resolution of catimg.
#
# Default: '2'
# Values:  '1', '2'
# Flags:   --catimg_size
catimg_size="2"

# Gap between image and text
#
# Default: '3'
# Values:  'num', '-num'
# Flag:    --gap
gap=3

# Image offsets
# Only works with the w3m backend.
#
# Default: '0'
# Values:  'px'
# Flags:   --xoffset
#          --yoffset
yoffset=0
xoffset=0

# Image background color
# Only works with the w3m backend.
#
# Default: ''
# Values:  'color', 'blue'
# Flag:    --bg_color
background_color=


# Misc Options

# Stdout mode
# If enabled, turn off all colors and disables image backend (ASCII/Image).
# Useful for piping into another command.
# Default: 'auto'
# Values: 'auto', 'on', 'off'
stdout="auto"
EOF

# If /etc/neofetch/default.conf exist, set config variable to its content
if [[ -f /etc/neofetch/default.conf ]]; then
    config="$(< /etc/neofetch/default.conf)"
fi

# DETECT INFORMATION

get_os() {
    # $kernel_name is set in a function called cache_uname and is
    # just the output of "uname -s".
    # case $kernel_name in
      #  Darwin)   os=$darwin_name ;;
       # SunOS)    case $(uname -o 2>/dev/null) in
       #               illumos)  os=illumos ;;
       #               *)        os=Solaris ;;
     #             esac ;;
     #   Haiku)    os=Haiku ;;
     #   MINIX)    os=MINIX ;;
     #   AIX)      os=AIX ;;
     #   IRIX*)    os=IRIX ;;
     #   FreeMiNT) os=FreeMiNT ;;
     #   Interix)  os=Interix ;;
     #   Ironclad) os=Ironclad;;
     #   OSF1)     os=digitalUNIX ;;

#   Linux|GNU*)
            os=Linux
 #       ;;

  #      *BSD|DragonFly|Bitrig)
   #         os=BSD
   #     ;;

#        CYGWIN*|MSYS*|MINGW*|Windows_NT)
 #           os=Windows
  #      ;;

   #     *)
    #        printf '%s\n' "Unknown OS detected: '$kernel_name', aborting..." >&2
     #       printf '%s\n' "Open an issue on GitHub to add support for your OS." >&2
      #      exit 1
       # ;;
    #esac
}

get_distro() {

    [[ $distro ]] && return

    # case $os in
    #  Ironclad) distro=Ironclad ;;
    #     Linux|BSD|MINIX)
    #         if [[ -f /bedrock/etc/bedrock-release && -z $BEDROCK_RESTRICT ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="Bedrock Linux" ;;
    #                 *) distro=$(< /bedrock/etc/bedrock-release)
    #             esac

    #         elif [[ -f /System/Library/CoreServices/SystemVersion.plist ]]; then
    #             os=ravynOS
    #             ascii_distro="ravynOS"
    #             case $distro_shorthand in
    #                 tiny) distro="$darwin_name" ;;
    #                 on) distro="$darwin_name $osx_version" ;;
    #                 *) distro="$darwin_name $darwin_family $osx_version"
    #             esac
    #         elif [[ -f /etc/redstar-release ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="Red Star OS" ;;
    #                 *) distro="Red Star OS $(awk -F'[^0-9*]' '$0=$2' /etc/redstar-release)"
    #             esac

    #         elif [[ -f /etc/KrassOS.version ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="KrassOS" ;;
    #                 *) distro="KrassOS $(awk '/release/{print $2}' /etc/KrassOS.version)"
    #             esac


    #         elif [[ -f /etc/armbian-release ]]; then
    #             . /etc/armbian-release
    #             distro="Armbian $DISTRIBUTION_CODENAME (${VERSION:-})"

    #         elif [[ -f /etc/manjaro-release ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="Manjaro Linux" ;;
    #                 *) distro="Manjaro Linux $(lsb_release -src)"
    #             esac

    #         elif [[ -f /etc/siduction-version ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro=Siduction ;;
    #                 *) distro="Siduction ($(lsb_release -sic))"
    #             esac

    #         elif [[ -f /etc/q4os_version ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="Q4OS" ;;
    #                 *) distro="Q4OS $(cat /etc/q4os_version)"
    #             esac

    #         elif [[ -f /etc/mcst_version ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="OS Elbrus" ;;
    #                 *) distro="OS Elbrus $(< /etc/mcst_version)"
    #             esac

    #         elif [[ -f /etc/NIXOS ]]; then
    #             case $distro_shorthand in
    #                 on) distro="NixOS $(nixos-version | awk '{print substr($1,0,5),$2}')" ;;
    #                 tiny) distro="NixOS" ;;
    #                 *) distro="NixOS $(nixos-version)" ;;
    #             esac

    #         elif [[ -f /etc/linspire-version ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="Linspire" ;;
    #                 *) distro="Linspire $(awk '/Version/ {print $2}' /etc/linspire-version)"
    #             esac

    #         elif [[ -f /etc/lindowsos-version ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="LindowsOS" ;;
    #                 *) distro="$(awk '/Version/ {print $2,$3}' /etc/lindowsos-version)"
    #             esac

    #         elif [[ -f /etc/astra_version ]]; then
    #             distro="Astra Linux"
    #             distro_version="$(sed -nr 's/^[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/p' < /etc/astra_version)"
    #             if [[ $distro_version == "2.12"* ]]; then
    #                 distro_codename="ALCE"
    #             else
    #                 distro_codename="ALSE"
    #             fi
    #             case $distro_shorthand in
    #                 on|tiny) ;;
    #                 *) distro="${distro} ${distro_version} ${distro_codename}"
    #             esac

    #         elif type -p pveversion >/dev/null; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="Proxmox VE" ;;
    #                 *)
    #                     distro=$(pveversion)
    #                     distro=${distro#pve-manager/}
    #                     distro="Proxmox VE ${distro%/*}"
    #             esac

    #         elif type -p twistver >/dev/null; then
    #             if [[ -f /etc/armbian-release ]]; then
    #                 . /etc/armbian-release
    #                 case $distro_shorthand in
    #                     on)   distro="$( twistver ) (Armbian ${VERSION})" ;;
    #                     tiny) distro="$( twistver ) (Armbian)" ;;
    #                     off)  distro="$( twistver ) (Armbian ${VERSION} ${DISTRIBUTION_CODENAME})" ;;
    #                 esac
    #             else
    #                 . /etc/os-release
    #                 case $distro_shorthand in
    #                     on)   distro="$( twistver ) ($NAME ${VERSION_ID})" ;;
    #                     tiny) distro="$( twistver ) ($NAME)" ;;
    #                     off)  distro="$( twistver ) (${PRETTY_NAME}})" ;;
    #                 esac
    #             fi

    #         elif type -p anise >/dev/null; then
    #             for file in /etc/lsb-release /etc/os-release ; do
    #                 source "$file"
    #             done

    #             case $distro_shorthand in
    #                 on|tiny) distro="${NAME:-${DISTRIB_DESCRIPTION:-MacaroniOS}}" ;;
    #                 *)
    #                     distro="${NAME:-${DISTRIB_DESCRIPTION:-MacaroniOS}} ${VERSION:-${DISTRIB_RELEASE}}"
    #             esac

    #         elif type -p lsb_release >/dev/null; then
    #             # Debian does not include .x versions in /etc/os-version, but does in debian_version
    #             # So if that file exists, and we are not *buntu, build name from there
    #             if [[ -f /etc/debian_version ]] && [[ $(lsb_release -si) != *"buntu"* ]] && [[ $(lsb_release -si) != *"neon"* ]]; then
    #                 . /etc/os-release
    #                 case $distro_shorthand in
    #                     on)   distro="${NAME}" ;;
    #                     tiny) distro="$(lsb_release -si)" ;;
    #                     *)    distro="${NAME} $(< /etc/debian_version) (${VERSION_CODENAME})" ;;
    #                 esac
    #             else
    #                 case $distro_shorthand in
    #                     on)   lsb_flags=-si ;;
    #                     tiny) lsb_flags=-si ;;
    #                     *)    lsb_flags=-sd ;;
    #                 esac
    #                 distro=$(lsb_release "$lsb_flags")
    #             fi

    #         elif [[ -f /etc/os-release || \
    #                 -f /usr/lib/os-release || \
    #                 -f /etc/openwrt_release || \
    #                 -f /etc/lsb-release ]]; then

    #             # Source the os-release file
    #             for file in /etc/lsb-release    /etc/os-release \
    #                         /usr/lib/os-release /etc/openwrt_release; do
    #                 source "$file" && break
    #             done

    #             # Format the distro name.
    #             case $distro_shorthand in
    #                 on)   distro="${NAME:-${DISTRIB_ID}} ${VERSION_ID:-${DISTRIB_RELEASE}}" ;;
    #                 tiny) distro="${NAME:-${DISTRIB_ID:-${TAILS_PRODUCT_NAME}}}" ;;
    #                 off)  distro="${PRETTY_NAME:-${DISTRIB_DESCRIPTION}} ${UBUNTU_CODENAME}" ;;
    #             esac

    #             # Workaround for NomadBSD.
    #             [[ $distro = "FreeBSD"* ]] && [[ -f /usr/bin/nomadbsd-sysinfo ]] && distro=NomadBSD

    #         elif [[ -f /etc/GoboLinuxVersion ]]; then
    #             case $distro_shorthand in
    #                 on|tiny) distro=GoboLinux ;;
    #                 *) distro="GoboLinux $(< /etc/GoboLinuxVersion)"
    #             esac

    #         elif [[ -f /etc/SDE-VERSION ]]; then
    #             distro="$(< /etc/SDE-VERSION)"
    #             case $distro_shorthand in
    #                 on|tiny) distro="${distro% *}" ;;
    #             esac

    #         elif type -p crux >/dev/null; then
    #             distro=$(crux)
    #             case $distro_shorthand in
    #                 on)   distro=${distro//version} ;;
    #                 tiny) distro=${distro//version*}
    #             esac

    #         elif type -p tazpkg >/dev/null; then
    #             distro="SliTaz $(< /etc/slitaz-release)"

    #         elif type -p kpt >/dev/null && \
    #              type -p kpm >/dev/null; then
    #             distro=KSLinux

    #         elif [[ -d /system/app/ && -d /system/priv-app ]]; then
    #             distro="Android $(getprop ro.build.version.release)"

    #         elif [[ -f /etc/vzlinux-release ]]; then
    #             distro='VzLinux'

    #         # Chrome OS doesn't conform to the /etc/*-release standard.
    #         # While the file is a series of variables they can't be sourced
    #         # by the shell since the values aren't quoted.
    #         elif grep -q CHROMEOS /etc/lsb-release; then
    #             distro='Chrome OS'

    #         elif type -p guix >/dev/null; then
    #             case $distro_shorthand in
    #                 on|tiny) distro="Guix System" ;;
    #                 *) distro="Guix System $(guix -V | awk 'NR==1{printf $4}')"
    #             esac

    #         # Display whether using '-current' or '-release' on OpenBSD.
    #         elif [[ $kernel_name = OpenBSD ]] ; then
    #             read -ra kernel_info <<< "$(sysctl -n kern.version)"
    #             distro=${kernel_info[*]:0:2}

    #         elif [[ -f /etc/VERSION ]]; then
    #             # Source the DSM VERSION file
    #             source /etc/VERSION
    #             distro="Synology DSM ${productversion}-${buildnumber} Update ${smallfixnumber}"

    #         elif compgen -G "/usr/bin/*peropesis*" > /dev/null; then
    #             distro="Peropesis"

    #         else
    #             for release_file in /etc/*-release; do
    #                 distro+=$(< "$release_file")
    #             done

    #             if [[ -z $distro ]]; then
    #                 case $distro_shorthand in
    #                     on|tiny) distro=$kernel_name ;;
    #                     *) distro="$kernel_name $kernel_version" ;;
    #                 esac

    #                 distro=${distro/DragonFly/DragonFlyBSD}

    #                 # Workarounds for some BSD based distros.
    #                 [[ -f /etc/os-release ]]       && distro=Enso
    #                 [[ -f /etc/pcbsd-lang ]]       && distro=PCBSD
    #                 [[ -f /etc/trueos-lang ]]      && distro=TrueOS
    #                 [[ -f /etc/pacbsd-release ]]   && distro=PacBSD
    #                 [[ -f /etc/hbsd-update.conf ]] && distro=HardenedBSD

    #                 # /etc/pacbsd-release is an empty file
    #                 [[ -f "/etc/pacbsd-release" ]] && distro="PacBSD"

    #                 # For OPNsense
    #                 if [[ -f "/usr/local/opnsense/version/opnsense" ]]; then
    #                     case "$distro_shorthand" in
    #                         "on" | "tiny") distro="OPNsense" ;;
    #                         *)
    #                             distro=$(<"/usr/local/opnsense/version/opnsense")
    #                             distro="OPNsense ${distro%-*}"
    #                     esac
    #                 fi
    #             fi
    #         fi

    #         # Gets the windows tag caption (ie `Microsoft Windows 11 Pro Insider Preview`)
    #         #
    #         # Then removes the `Microsoft` and `Windows` part and gets the current
    #         # version of Windows (old code reported Windows 10 even if host runs Windows 11).
    #         #
    #         # Finally, we decline it in three versions :
    #         #
    #         # - The `on`   version (ie `[Windows 11.0.25330]`)
    #         # - The `tiny` version (ie `Windows 11`)
    #         # - The `any`  version (ie `on Windows 11 Pro Insider Preview`)
    #         if [[ $(< /proc/version) == *Microsoft* || $kernel_version == *Microsoft* ]]; then

    #             windows_version_verbose=$(reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -v ProductName | grep REG_)
    #             windows_version_verbose=$(trim "${windows_version_verbose/ProductName}")
    #             windows_version_verbose=$(trim "${windows_version_verbose/REG_SZ}")
    #             buildnumber=$(reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -v CurrentBuildNumber | grep REG_)
    #             windows_version_verbose=$(trim "${windows_version_verbose/Windows}")
    #             windows_buildnumber=$(reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -v CurrentBuildNumber | grep REG_)
    #             windows_buildnumber=${buildnumber/CurrentBuildNumber}
    #             windows_buildnumber=${buildnumber/REG_SZ}
    #             if [[ "$windows_version_verbose" == *"10"* ]] && (( windows_buildnumber >= 22000 )); then
    #                 windows_version_verbose=${windows_version_verbose/10/11}
    #             fi

    #             windows_version_current=${windows_version_verbose//[^[:digit:]]/}

    #             windows_version_number_long=$(wmic.exe os get Version)
    #             windows_version_number_long=$(trim "${windows_version_number_long/Version}")
    #             windows_version_number_long=$(trim "${windows_version_number_long}")
    #             windows_version_number_long="${windows_version_current}${windows_version_number_long:2}"

    #             case $distro_shorthand in
    #                 on)   distro+=" [Windows $windows_version_number_long]" ;;
    #                 tiny) distro=" Windows $windows_version_current" ;;
    #                 *)    distro+=" on Windows $windows_version_verbose" ;;
    #             esac

    #         # Chrome OS doesn't conform to the /etc/*-release standard.
    #         # While the file is a series of variables they can't be sourced
    #         # by the shell since the values aren't quoted.
    #         elif [[ -f /etc/lsb-release && $(< /etc/lsb-release) == *CHROMEOS* ]]; then
    #             distro='Chrome OS'

    #         elif [[ $(< /proc/version) == *chrome-bot* || -f /dev/cros_ec ]]; then
    #             # gets chrome os version from /etc/lsb-release.
    #             # totally not written by chatgpt :trolley:
    #             cros_version=$(grep -oE 'CHROMEOS_RELEASE_CHROME_MILESTONE=([0-9]+)' /etc/lsb-release | cut -d= -f2)
    #             [[ $distro != *Chrome* ]] &&
    #                 case $distro_shorthand in
    #                     on)   distro="Chrome OS $cros_version" ;;
    #                     tiny) distro="Chrome OS" ;;
    #                     *)    distro="Chrome OS $cros_version $distro" ;;
    #                 esac
    #         fi

    #         distro=$(trim_quotes "$distro")
    #         distro=${distro/NAME=}

    #         if [[ -f /usr/bin/system-image-cli ]]; then
    #             local ut_ota
    #             ut_ota=$(system-image-cli -i | awk '/version tag:/ { print $3 }');
    #             distro="Ubuntu Touch $ut_ota";

    #             # There's a weird UT bug where the HOSTNAME is set to android.
    #             HOSTNAME=$(hostname);
    #         fi

    #         # Get Ubuntu flavor.
    #         if [[ $distro == "Ubuntu"* ]]; then
    #             case $XDG_CONFIG_DIRS in
    #                 *"studio"*)   distro=${distro/Ubuntu/Ubuntu Studio} ;;
    #                 *"kde"*)      distro=${distro/Ubuntu/Kubuntu} ;;
    #                 *"plasma"*)   distro=${distro/Ubuntu/Kubuntu} ;;
    #                 *"mate"*)     distro=${distro/Ubuntu/Ubuntu MATE} ;;
    #                 *"xubuntu"*)  distro=${distro/Ubuntu/Xubuntu} ;;
    #                 *"Lubuntu"*)  distro=${distro/Ubuntu/Lubuntu} ;;
    #                 *"budgie"*)   distro=${distro/Ubuntu/Ubuntu Budgie} ;;
    #                 *"cinnamon"*) distro=${distro/Ubuntu/Ubuntu Cinnamon} ;;
    #                 *"ubuntusway"*) distro=${distro/Ubuntu/Ubuntu Sway} ;;
    #                 *"ukui"*)     distro=${distro/Ubuntu/Ubuntu Kylin} ;;
    #             esac
    #             if [[ -f /etc/floflis-release ]]; then
    #                 distro="Floflis"
    #             fi
    #         fi

    #         # Get Fedora immutable spin.
    #         if [[ $distro == "Fedora"* ]]; then
    #             case $VARIANT in
    #                 "CoreOS" | "Kinoite" | "Sericea" | "Silverblue")
    #                     case $distro_shorthand in
    #                         on)   distro="Fedora $VARIANT $VERSION_ID" ;;
    #                         tiny) distro="$VARIANT";;
    #                         *)    distro="Fedora $VARIANT $OSTREE_VERSION" ;;
    #                     esac
    #                     ;;
    #             esac
    #         fi
    #     ;;

    #     "Mac OS X"|"macOS")
    #         case $osx_version in
    #             10.4*)  codename="Mac OS X Tiger"        ;;
    #             10.5*)  codename="Mac OS X Leopard"      ;;
    #             10.6*)  codename="Mac OS X Snow Leopard" ;;
    #             10.7*)  codename="Mac OS X Lion"         ;;
    #             10.8*)  codename="OS X Mountain Lion"    ;;
    #             10.9*)  codename="OS X Mavericks"        ;;
    #             10.10*) codename="OS X Yosemite"         ;;
    #             10.11*) codename="OS X El Capitan"       ;;
    #             10.12*) codename="macOS Sierra"          ;;
    #             10.13*) codename="macOS High Sierra"     ;;
    #             10.14*) codename="macOS Mojave"          ;;
    #             10.15*) codename="macOS Catalina"        ;;
    #             10.16*) codename="macOS Big Sur"         ;;
    #             11.*)   codename="macOS Big Sur"         ;;
    #             12.*)   codename="macOS Monterey"        ;;
    #             13.*)   codename="macOS Ventura"         ;;
    #             14.*)   codename="macOS Sonoma"          ;;
    #             *)      codename="macOS"                 ;;
    #         esac

    #         distro="$codename $osx_version ($osx_build)"

    #         case $distro_shorthand in
    #             on) distro=${distro/ ${osx_build}} ;;

    #             tiny)
    #                 case $osx_version in
    #                     10.[4-7]*)            distro=${distro/${codename}/Mac OS X} ;;
    #                     10.[8-9]*|10.1[0-1]*) distro=${distro/${codename}/OS X} ;;
    #                     10.1[2-6]*|11.0*)     distro=${distro/${codename}/macOS} ;;
    #                 esac
    #                 distro=${distro/ ${osx_build}}
    #             ;;
    #         esac
    #     ;;

    #     "iPhone OS")
    #         distro="iOS $osx_version"

    #         # "uname -m" doesn't print architecture on iOS.
    #         os_arch=off
    #     ;;

    #     Windows)
    #         distro=$(reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -v ProductName | grep REG_)
    #         distro=${distro/ProductName}
    #         distro=${distro/REG_SZ}
    #         buildnumber=$(reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -v CurrentBuildNumber | grep REG_)
    #         buildnumber=${buildnumber/CurrentBuildNumber}
    #         buildnumber=${buildnumber/REG_SZ}

    #         # If the value of "ProductName" obtained is Windows 10 and the value of "CurrentBuildNumber" is greater than 22000, then the actual operating system version is Windows 11.
    #         if [[ "$distro" == *"Windows 10"* ]] && (( buildnumber >= 22000 )); then
    #             distro=${distro/Windows 10/Windows 11}
    #         fi
    #     ;;

    #     Solaris|illumos)
    #         case $distro_shorthand in
    #             on|tiny) distro=$(awk 'NR==1 {print $1,$3}' /etc/release) ;;
    #             *)       distro=$(awk 'NR==1 {print $1,$2,$3}' /etc/release) ;;
    #         esac
    #         distro=${distro/\(*}
    #     ;;

    #     Haiku)
    #         distro=Haiku
    #     ;;

    #     AIX)
    #         distro="AIX $(oslevel)"
    #     ;;

    #     IRIX)
    #         distro="IRIX ${kernel_version}"
    #     ;;

    #     FreeMiNT)
    #         distro=FreeMiNT
    #     ;;

    #     Interix)
    #         distro="Interix ${kernel_version}"
    #     ;;

    #     digitalUNIX)
    #         distro="digital UNIX ${kernel_version}"
    #     ;;
    # esac

    # distro=${distro//Enterprise Server}

    # [[ $distro ]] || distro="$os (Unknown)"

    # # Get OS architecture.
    # case $os in
    #     Solaris|illumos|AIX|Haiku|IRIX|FreeMiNT|BSD|digitalUNIX)
    #         machine_arch=$(uname -p)
    #     ;;

    #     *)  machine_arch=$kernel_machine ;;
    # esac

    # [[ $os_arch == on ]] && \
    #     distro+=" $machine_arch"

    # [[ ${ascii_distro:-auto} == auto ]] && \
    #     ascii_distro=$(trim "$distro")
    distro="Arch"
}

get_bios() {
    DMI="/sys/devices/virtual/dmi/id"

    # TODO: Add more platform support for bios detection
    case $os in
        Linux)
            if [[ -f "$DMI/bios_vendor" ]]; then
                bios="$(< $DMI/bios_vendor)"

                if [[ -f "$DMI/bios_release" ]]; then
                    bios+=" $(< $DMI/bios_release)"
                fi

                if [[ -f "$DMI/bios_date" ]]; then
                    bios+=" ($(< $DMI/bios_date))"
                fi
            fi
        ;;
    esac
}

get_model() {
    case $os in
        Linux)
            if [[ -d /android/system/ || -d /system/app/ ]]; then
                model="$(getprop ro.product.brand) $(getprop ro.product.model)"

            elif [[ -f /sys/devices/virtual/dmi/id/product_name ||
                    -f /sys/devices/virtual/dmi/id/product_version ]]; then
                model=$(< /sys/devices/virtual/dmi/id/product_name)
                model+=" $(< /sys/devices/virtual/dmi/id/product_version)"

            elif [[ -f /sys/devices/virtual/dmi/id/board_vendor ||
                    -f /sys/devices/virtual/dmi/id/board_name ]]; then
                model=$(< /sys/devices/virtual/dmi/id/board_vendor)
                model+=" $(< /sys/devices/virtual/dmi/id/board_name)"

            elif [[ -f /sys/firmware/devicetree/base/model ]]; then
                model=$(< /sys/firmware/devicetree/base/model)

            elif [[ -f /tmp/sysinfo/model ]]; then
                model=$(< /tmp/sysinfo/model)
            fi
        ;;

        "Mac OS X"|"macOS"|"ravynOS")
            if [ "$(arch)" != "arm64" ] && [[ $(kextstat | grep -F -e "FakeSMC" -e "VirtualSMC") != "" ]]; then
                model="Hackintosh (SMBIOS: $(sysctl -n hw.model))"
            else
                if [[ $osx_version == 10.[4-5]* ]]; then
                    model="$(system_profiler SPHardwareDataType | grep Machine\ Name:)"
                    model=${model/Machine\ Name\:/}

                    model="$model ($(sysctl -n hw.model))"
                else
                    model=$(sysctl -n hw.model)
                fi

                case $model in
                    Mac14,15):              "MacBook Air (15-inch, M2, 2023)" ;;
                    Mac14,14):              "Mac Studio (M2 Ultra, 2023)" ;;
                    Mac14,13):              "Mac Studio (M2 Max, 2023)" ;;
                    Mac14,8):               "Mac Pro (2023)" ;;
                    Mac14,6 | Mac14,10):    "MacBook Pro (16-inch, 2023)" ;;
                    Mac14,5 | Mac14,9):     "MacBook Pro (14-inch, 2023)" ;;
                    Mac14,12 | Mac14,3):    "Mac mini (2023)" ;;
                    Mac14,7):               "MacBook Pro (13-inch, M2, 2022)" ;;
                    Mac14,2):               "MacBook Air (M2, 2022)" ;;
                    Mac13,1):               "Mac Studio (M1 Max, 2022)" ;;
                    Mac13,2):               "Mac Studio (M1 Ultra, 2022)" ;;
                    MacBookPro18,[3-4]):    "MacBook Pro (14-inch, 2021)" ;;
                    MacBookPro18,[1-2]):    "MacBook Pro (16-inch, 2021)" ;;
                    MacBookPro17,1):        "MacBook Pro (13-inch, M1, 2020)" ;;
                    MacBookPro16,4):        "MacBook Pro (16-inch, 2019)" ;;
                    MacBookPro16,3):        "MacBook Pro (13-inch, 2020, Two Thunderbolt 3 ports)" ;;
                    MacBookPro16,2):        "MacBook Pro (13-inch, 2020, Four Thunderbolt 3 ports)" ;;
                    MacBookPro16,1):        "MacBook Pro (16-inch, 2019)" ;;
                    MacBookPro15,4):        "MacBook Pro (13-inch, 2019, Two Thunderbolt 3 ports)" ;;
                    MacBookPro15,3):        "MacBook Pro (15-inch, 2019)" ;;
                    MacBookPro15,2):        "MacBook Pro (13-inch, 2018/2019, Four Thunderbolt 3 ports)" ;;
                    MacBookPro15,1):        "MacBook Pro (15-inch, 2018/2019)" ;;
                    MacBookPro14,3):        "MacBook Pro (15-inch, 2017)" ;;
                    MacBookPro14,2):        "MacBook Pro (13-inch, 2017, Four Thunderbolt 3 ports)" ;;
                    MacBookPro14,1):        "MacBook Pro (13-inch, 2017, Two Thunderbolt 3 ports)" ;;
                    MacBookPro13,3):        "MacBook Pro (15-inch, 2016)" ;;
                    MacBookPro13,2):        "MacBook Pro (13-inch, 2016, Four Thunderbolt 3 ports)" ;;
                    MacBookPro13,1):        "MacBook Pro (13-inch, 2016, Two Thunderbolt 3 ports)" ;;
                    MacBookPro12,1):        "MacBook Pro (Retina, 13-inch, Early 2015)" ;;
                    MacBookPro11,[4-5]):    "MacBook Pro (Retina, 15-inch, Mid 2015)" ;;
                    MacBookPro11,[2-3]):    "MacBook Pro (Retina, 15-inch, Late 2013/Mid 2014)" ;;
                    MacBookPro11,1):        "MacBook Pro (Retina, 13-inch, Late 2013/Mid 2014)" ;;
                    MacBookPro10,2):        "MacBook Pro (Retina, 13-inch, Late 2012/Early 2013)" ;;
                    MacBookPro10,1):        "MacBook Pro (Retina, 15-inch, Mid 2012/Early 2013)" ;;
                    MacBookPro9,2):         "MacBook Pro (13-inch, Mid 2012)" ;;
                    MacBookPro9,1):         "MacBook Pro (15-inch, Mid 2012)" ;;
                    MacBookPro8,3):         "MacBook Pro (17-inch, 2011)" ;;
                    MacBookPro8,2):         "MacBook Pro (15-inch, 2011)" ;;
                    MacBookPro8,1):         "MacBook Pro (13-inch, 2011)" ;;
                    MacBookPro7,1):         "MacBook Pro (13-inch, Mid 2010)" ;;
                    MacBookPro6,2):         "MacBook Pro (15-inch, Mid 2010)" ;;
                    MacBookPro6,1):         "MacBook Pro (17-inch, Mid 2010)" ;;
                    MacBookPro5,5):         "MacBook Pro (13-inch, Mid 2009)" ;;
                    MacBookPro5,3):         "MacBook Pro (15-inch, Mid 2009)" ;;
                    MacBookPro5,2):         "MacBook Pro (17-inch, Mid/Early 2009)" ;;
                    MacBookPro5,1):         "MacBook Pro (15-inch, Late 2008)" ;;
                    MacBookPro4,1):         "MacBook Pro (17/15-inch, Early 2008)" ;;
                    MacBookAir10,1):        "MacBook Air (M1, 2020)" ;;
                    MacBookAir9,1):         "MacBook Air (Retina, 13-inch, 2020)" ;;
                    MacBookAir8,2):         "MacBook Air (Retina, 13-inch, 2019)" ;;
                    MacBookAir8,1):         "MacBook Air (Retina, 13-inch, 2018)" ;;
                    MacBookAir7,2):         "MacBook Air (13-inch, Early 2015/2017)" ;;
                    MacBookAir7,1):         "MacBook Air (11-inch, Early 2015)" ;;
                    MacBookAir6,2):         "MacBook Air (13-inch, Mid 2013/Early 2014)" ;;
                    MacBookAir6,1):         "MacBook Air (11-inch, Mid 2013/Early 2014)" ;;
                    MacBookAir5,2):         "MacBook Air (13-inch, Mid 2012)" ;;
                    MacBookAir5,1):         "MacBook Air (11-inch, Mid 2012)" ;;
                    MacBookAir4,2):         "MacBook Air (13-inch, Mid 2011)" ;;
                    MacBookAir4,1):         "MacBook Air (11-inch, Mid 2011)" ;;
                    MacBookAir3,2):         "MacBook Air (13-inch, Late 2010)" ;;
                    MacBookAir3,1):         "MacBook Air (11-inch, Late 2010)" ;;
                    MacBookAir2,1):         "MacBook Air (Mid 2009)" ;;
                    MacBook10,1):           "MacBook (Retina, 12-inch, 2017)" ;;
                    MacBook9,1):            "MacBook (Retina, 12-inch, Early 2016)" ;;
                    MacBook8,1):            "MacBook (Retina, 12-inch, Early 2015)" ;;
                    MacBook7,1):            "MacBook (13-inch, Mid 2010)" ;;
                    MacBook6,1):            "MacBook (13-inch, Late 2009)" ;;
                    MacBook5,2):            "MacBook (13-inch, Early/Mid 2009)" ;;
                    Macmini9,1):            "Mac mini (M1, 2020)" ;;
                    Macmini8,1):            "Mac mini (2018)" ;;
                    Macmini7,1):            "Mac mini (Mid 2014)" ;;
                    Macmini6,[1-2]):        "Mac mini (Late 2012)" ;;
                    Macmini5,[1-2]):        "Mac mini (Mid 2011)" ;;
                    Macmini4,1):            "MacPromini (Mid 2010)" ;;
                    Macmini3,1):            "Mac mini (Early/Late 2009)" ;;
                    MacPro7,1):             "Mac Pro (2019)" ;;
                    MacPro6,1):             "Mac Pro (Late 2013)" ;;
                    MacPro5,1):             "Mac Pro (Mid 2010 - Mid 2012)" ;;
                    MacPro4,1):             "Mac Pro (Early 2009)" ;;
                    iMac21,[1-2]):          "iMac (24-inch, M1, 2021)" ;;
                    iMac20,[1-2]):          "iMac (Retina 5K, 27-inch, 2020)" ;;
                    iMac19,[1-2]):          "iMac (Retina 4K, 21.5-inch, 2019)" ;;
                    iMacPro1,1):            "iMac Pro (2017)" ;;
                    iMac18,3):              "iMac (Retina 5K, 27-inch, 2017)" ;;
                    iMac18,2):              "iMac (Retina 4K, 21.5-inch, 2017)" ;;
                    iMac18,1):              "iMac (21.5-inch, 2017)" ;;
                    iMac17,1):              "iMac (Retina 5K, 27-inch, Late 2015)" ;;
                    iMac16,2):              "iMac (Retina 4K, 21.5-inch, Late 2015)" ;;
                    iMac16,1):              "iMac (21.5-inch, Late 2015)" ;;
                    iMac15,1):              "iMac (Retina 5K, 27-inch, Late 2014 - Mid 2015)" ;;
                    iMac14,4):              "iMac (21.5-inch, Mid 2014)" ;;
                    iMac14,2):              "iMac (27-inch, Late 2013)" ;;
                    iMac14,1):              "iMac (21.5-inch, Late 2013)" ;;
                    iMac13,2):              "iMac (27-inch, Late 2012)" ;;
                    iMac13,1):              "iMac (21.5-inch, Late 2012)" ;;
                    iMac12,2):              "iMac (27-inch, Mid 2011)" ;;
                    iMac12,1):              "iMac (21.5-inch, Mid 2011)" ;;
                    iMac11,3):              "iMac (27-inch, Mid 2010)" ;;
                    iMac11,2):              "iMac (21.5-inch, Mid 2010)" ;;
                    iMac10,1):              "iMac (27/21.5-inch, Late 2009)" ;;
                    iMac9,1):               "iMac (24/20-inch, Early 2009)" ;;
                    *):                     "$model" ;;
                esac

                model=$_
            fi
        ;;

        "iPhone OS")
            case $kernel_machine in
                iPad1,1):            "iPad" ;;
                iPad1,2):            "iPad 3G" ;;
                iPad2,[1-4]):        "iPad 2" ;;
                iPad3,[1-3]):        "iPad 3" ;;
                iPad3,[4-6]):        "iPad 4" ;;
                iPad6,1[1-2]):       "iPad 5" ;;
                iPad7,[5-6]):        "iPad 6" ;;
                iPad7,1[1-2]):       "iPad 7" ;;
                iPad11,[6-7]):       "iPad 8" ;;
                iPad12,[1-2]):       "iPad 9" ;;
                iPad13,1[8-9]):      "iPad 10" ;;
                iPad4,[1-3]):        "iPad Air" ;;
                iPad5,[3-4]):        "iPad Air 2" ;;
                iPad11,[3-4]):       "iPad Air 3" ;;
                iPad13,[1-2]):       "iPad Air 4" ;;
                iPad13,1[6-7]):      "iPad Air 5" ;;
                iPad6,[7-8]):        "iPad Pro 12.9-inch" ;;
                iPad6,[3-4]):        "iPad Pro 9.7-inch" ;;
                iPad7,[1-2]):        "iPad Pro 12.9-inch (2nd generation)" ;;
                iPad7,[3-4]):        "iPad Pro 10.5-inch" ;;
                iPad8,[1-4]):        "iPad Pro 11-inch" ;;
                iPad8,[5-8]):        "iPad Pro 12.9-inch (3rd generation)" ;;
                iPad8,9 | iPad8,10): "iPad Pro 11-inch (2nd generation)" ;;
                iPad8,1[1-2]):       "iPad Pro 12.9-inch (4th generation)" ;;
                iPad13,[4-7]):       "iPad Pro 11-inch (3rd generation)" ;;
                iPad13,[8-9]):       "iPad Pro 12.9-inch (5th generation)" ;;
                iPad13,1[0-1]):      "iPad Pro 12.9-inch (5th generation)" ;;
                iPad14,[3-4]):       "iPad Pro 11-inch (4th generation)" ;;
                iPad14,[5-6]):       "iPad Pro 12.9-inch (6th generation)" ;;
                iPad2,[5-7]):        "iPad mini" ;;
                iPad4,[4-6]):        "iPad mini 2" ;;
                iPad4,[7-9]):        "iPad mini 3" ;;
                iPad5,[1-2]):        "iPad mini 4" ;;
                iPad11,[1-2]):       "iPad mini 5" ;;
                iPad14,[1-2]):       "iPad mini 6" ;;

                iPhone1,1):     "iPhone" ;;
                iPhone1,2):     "iPhone 3G" ;;
                iPhone2,1):     "iPhone 3GS" ;;
                iPhone3,[1-3]): "iPhone 4" ;;
                iPhone4,1):     "iPhone 4S" ;;
                iPhone5,[1-2]): "iPhone 5" ;;
                iPhone5,[3-4]): "iPhone 5c" ;;
                iPhone6,[1-2]): "iPhone 5s" ;;
                iPhone7,2):     "iPhone 6" ;;
                iPhone7,1):     "iPhone 6 Plus" ;;
                iPhone8,1):     "iPhone 6s" ;;
                iPhone8,2):     "iPhone 6s Plus" ;;
                iPhone8,4):     "iPhone SE" ;;
                iPhone9,[13]):  "iPhone 7" ;;
                iPhone9,[24]):  "iPhone 7 Plus" ;;
                iPhone10,[14]): "iPhone 8" ;;
                iPhone10,[25]): "iPhone 8 Plus" ;;
                iPhone10,[36]): "iPhone X" ;;
                iPhone11,2):    "iPhone XS" ;;
                iPhone11,[46]): "iPhone XS Max" ;;
                iPhone11,8):    "iPhone XR" ;;
                iPhone12,1):    "iPhone 11" ;;
                iPhone12,3):    "iPhone 11 Pro" ;;
                iPhone12,5):    "iPhone 11 Pro Max" ;;
                iPhone12,8):    "iPhone SE 2020" ;;
                iPhone13,1):    "iPhone 12 Mini" ;;
                iPhone13,2):    "iPhone 12" ;;
                iPhone13,3):    "iPhone 12 Pro" ;;
                iPhone13,4):    "iPhone 12 Pro Max" ;;
                iPhone14,2):    "iPhone 13 Pro" ;;
                iPhone14,3):    "iPhone 13 Pro Max" ;;
                iPhone14,4):    "iPhone 13 Mini" ;;
                iPhone14,5):    "iPhone 13" ;;
                iPhone14,6):    "iPhone SE 2022" ;;
                iPhone14,7):    "iPhone 14" ;;
                iPhone14,8):    "iPhone 14 Plus" ;;
                iPhone15,2):    "iPhone 14 Pro" ;;
                iPhone15,3):    "iPhone 14 Pro Max" ;;

                iPod1,1): "iPod touch" ;;
                iPod2,1): "iPod touch 2G" ;;
                iPod3,1): "iPod touch 3G" ;;
                iPod4,1): "iPod touch 4G" ;;
                iPod5,1): "iPod touch 5G" ;;
                iPod7,1): "iPod touch 6G" ;;
                iPod9,1): "iPod touch 7G" ;;
            esac

            model=$_
        ;;

        BSD|MINIX)
            if [[ $kernel_name = "FreeBSD" ]]; then
                model=$(kenv smbios.system.version)
            else
                model=$(sysctl -n hw.vendor hw.product)
            fi
        ;;

        Windows)
            model=$(wmic computersystem get manufacturer,model)
            model=${model/Manufacturer}
            model=${model/Model}
        ;;

        Solaris|illumos)
            model=$(prtconf -b | awk -F':' '/banner-name/ {printf $2}')
            if virt=$(/usr/bin/uname -V) && [[ "$virt" != "non-virtualized" ]]; then
                model="${model:-$(uname -i)} (${virt})"
            fi
        ;;

        AIX)
            model=$(/usr/bin/uname -M)
        ;;

        FreeMiNT)
            model=$(sysctl -n hw.model)
            model=${model/ (_MCH *)}
        ;;

        Interix)
            model="$(/dev/fs/C/Windows/System32/wbem/WMIC.exe computersystem get manufacturer,model)"
            model="${model/Manufacturer}"
            model="${model/Model}"
        ;;
    esac

    # Remove dummy OEM info.
    model=${model//To be filled by O.E.M.}
    model=${model//To Be Filled*}
    model=${model//OEM*}
    model=${model//Not Applicable}
    model=${model//System Product Name}
    model=${model//System Version}
    model=${model//Undefined}
    model=${model//Default string}
    model=${model//Not Specified}
    model=${model//Type1ProductConfigId}
    model=${model//INVALID}
    model=${model//All Series}
    model=${model//�}

    case $model in
        "Standard PC"*) model="KVM/QEMU (${model})" ;;
        OpenBSD*)       model="vmm ($model)" ;;
    esac
}

get_title() {
    user=${USER:-$(id -un || printf %s "${HOME/*\/}")}

    case $title_fqdn in
        on)
            case $os in
                illumos|Solaris)
                    hostname=$(hostname)
                    domainname=$(domainname)
                    [[ -n "$domainname" ]] && hostname+=".$domainname"
                ;;
                *)
                    hostname=$(hostname -f)
                ;;
            esac
        ;;
        *)
            hostname=${HOSTNAME:-$(hostname)}
            hostname=${hostname%%.*}
        ;;
    esac

    title=${title_color}${bold}${user}${at_color}@${title_color}${bold}${hostname}
    length=$((${#user} + ${#hostname} + 1))
}

get_kernel() {
    # Since these OS are integrated systems, it's better to skip this function altogether
    [[ $os =~ (AIX|IRIX) ]] && return

    # Haiku uses 'uname -v' and not - 'uname -r'.
    [[ $os == Haiku ]] && {
        kernel=$(uname -v)
        return
    }

    # In Windows 'uname' may return the info of GNUenv thus use wmic for OS kernel.
    [[ $os == Windows ]] && {
        kernel=$(wmic os get Version)
        kernel=${kernel/Version}
        return
    }

    [[ $os == Solaris ]] && {
        ver=$(uname -v)
        case $ver in
            11.[0123]) ;;
            *) kernel=${ver} ;;
        esac
        return
    }

    # In Interix the Kernel version is commonly comprised of the host OS build number,
    # OS architecture and Interix build number
    [[ $os == Interix ]] && {
        kernel="$(uname -r) $(uname -m) $(uname -v)"
        return
    }

    case $kernel_shorthand in
        on)  kernel=$kernel_version ;;
        off) kernel="$kernel_name $kernel_version" ;;
    esac

    # Hide kernel info if it's identical to the distro info.
    [[ $os =~ (BSD|MINIX) && $distro == *"$kernel_name"* ]] &&
        case $distro_shorthand in
            on|tiny) kernel=$kernel_version ;;
            *)       unset kernel ;;
        esac
}

get_uptime() {
    # Get uptime in seconds.
    case $os in
        Ironclad)
            s=$(uptime -s)
        ;;
        Linux|Windows|MINIX)
            if [[ -r /proc/uptime ]]; then
                s=$(< /proc/uptime)
                s=${s/.*}
            else
                boot=$(date -d"$(uptime -s)" +%s)
                now=$(date +%s)
                s=$((now - boot))
            fi
        ;;

        "Mac OS X"|"macOS"|"ravynOS"|"iPhone OS"|BSD|FreeMiNT)
            boot=$(sysctl -n kern.boottime)
            boot=${boot/\{ sec = }
            boot=${boot/,*}

            # Get current date in seconds.
            now=$(date +%s)
            s=$((now - boot))
        ;;

        Solaris|illumos)
            boot=$(kstat -p unix:0:system_misc:boot_time | awk '{print $2}')
            now=$(date +%s)

            s=$((now - boot))
        ;;

        AIX|IRIX)
            t=$(LC_ALL=POSIX ps -o etime= -p 1)

            [[ $t == *-*   ]] && { d=${t%%-*}; t=${t#*-}; }
            [[ $t == *:*:* ]] && { h=${t%%:*}; t=${t#*:}; }

            h=${h#0}
            t=${t#0}

            s=$((${d:-0}*86400 + ${h:-0}*3600 + ${t%%:*}*60 + ${t#*:}))
        ;;

        Interix)
            t="$(LC_ALL=POSIX ps -o etime= -p 0)"
            t="${t%%.*}"

            [[ $t == *-*   ]] && { d=${t%%-*}; t=${t#*-}; }
            [[ $t == *:*:* ]] && { h=${t%%:*}; t=${t#*:}; }

            h="${h#0}"
            t="${t#0}"

            s="$((${d:-0}*86400 + ${h:-0}*3600 + ${t%%:*}*60 + ${t#*:}))"
        ;;

        Haiku)
            s=$(($(system_time) / 1000000))
        ;;
    esac

    d="$((s / 60 / 60 / 24)) days"
    h="$((s / 60 / 60 % 24)) hours"
    m="$((s / 60 % 60)) minutes"

    # Remove plural if < 2.
    ((${d/ *} == 1)) && d=${d/s}
    ((${h/ *} == 1)) && h=${h/s}
    ((${m/ *} == 1)) && m=${m/s}

    # Hide empty fields.
    ((${d/ *} == 0)) && unset d
    ((${h/ *} == 0)) && unset h
    ((${m/ *} == 0)) && unset m

    # Add "(!)" if more than 100 days
    ((${d/ *} > 100)) && d="${d}(!)"

    uptime=${d:+$d, }${h:+$h, }$m
    uptime=${uptime%', '}
    uptime=${uptime:-$s seconds}

    # Make the output of uptime smaller.
    case $uptime_shorthand in
        on)
            uptime=${uptime/ minutes/ mins}
            uptime=${uptime/ minute/ min}
            uptime=${uptime/ seconds/ secs}
        ;;

        tiny)
            uptime=${uptime/ days/d}
            uptime=${uptime/ day/d}
            uptime=${uptime/ hours/h}
            uptime=${uptime/ hour/h}
            uptime=${uptime/ minutes/m}
            uptime=${uptime/ minute/m}
            uptime=${uptime/ seconds/s}
            uptime=${uptime//,}
        ;;
    esac
}

get_packages() {
    # to adjust the number of pkgs per pkg manager
    pkgs_h=0

    # has: Check if package manager installed.
    # dir: Count files or dirs in a glob.
    # pac: If packages > 0, log package manager name.
    # tot: Count lines in command output.
    has() { type -p "$1" >/dev/null && manager=$1; }
    # globbing is intentional here
    # shellcheck disable=SC2206
    dir() { pkgs=($@); [[ ! -e ${pkgs[0]} ]] && return; ((packages+=${#pkgs[@]})); pac "$((${#pkgs[@]}-pkgs_h))"; }
    pac() { (($1 > 0)) && { managers+=("$1 (${manager})"); manager_string+="${manager}, "; }; }
    tot() {
        IFS=$'\n' read -d "" -ra pkgs <<< "$("$@")";
        ((packages+=${#pkgs[@]}));
        pac "$((${#pkgs[@]}-pkgs_h))";
    }
    # Similar with tot but do nothing if the command fails
    tot-safe() {
        if pkgs="$("$@")"; then
            pkgs=$(echo "$pkgs" | wc -l)
            ((packages+=pkgs))
            pac "$((pkgs-pkgs_h))";
        fi
    }

    # Redefine tot() and dir() for Bedrock Linux.
    [[ -f /bedrock/etc/bedrock-release && $PATH == */bedrock/cross/* ]] && {
        br_strata=$(brl list)
        tot() {
            IFS=$'\n' read -d "" -ra pkgs <<< "$(for s in ${br_strata}; do strat -r "$s" "$@"; done)"
            ((packages+="${#pkgs[@]}"))
            pac "$((${#pkgs[@]}-pkgs_h))";
        }
        dir() {
            local pkgs=()
            # globbing is intentional here
            # shellcheck disable=SC2206
            for s in ${br_strata}; do pkgs+=(/bedrock/strata/$s/$@); done
            ((packages+=${#pkgs[@]}))
            pac "$((${#pkgs[@]}-pkgs_h))"
        }
    }

    # Programming language package managers.
    if [[ -z "$package_minimal" ]]; then
        has pipx  && tot pipx list --short
        has cargo && _cargopkgs="$(cargo install --list | grep -v '^ ')" && tot echo "$_cargopkgs"

        # Special case for npm: If has npm, we should list folders under node_modules instead of using npm list.
        # This is because npm list is very slow (2s)
        if has npm; then
            # Try to apply heuristics to find the global directory.
            if [[ -d /usr/lib/node_modules ]]; then
                dir /usr/lib/node_modules/*/
            elif [[ -d /usr/local/lib/node_modules ]]; then
                dir /usr/local/lib/node_modules/*/
            else
                # If neither exist, use npm root -g to get the global directory.
                # (still ~10x faster than npm list)
                npm_global="$(npm root -g)"
                [[ -d "$npm_global" ]] && dir "$npm_global"/*/

                # This may not work in WSL2 (if npm is installed on Windows, not WSL).
                # However, if npm is not installed on this WSL subsystem, it doesn't really count
                # as a package manager for this subsystem, so let's ignore this case.
            fi
        fi

        # Relatively the same for pnpm
        if has pnpm; then
            # Try to apply heuristics to find the global directory.
            PNPM_P="local/share/pnpm/global/5/node_modules"
            if [[ -d "$HOME/.$PNPM_P" ]]; then
                dir "$HOME/.$PNPM_P"/*/
            elif [[ -d "/usr/$PNPM_P" ]]; then
                dir "/usr/$PNPM"/*/
            else
                # If neither exist, use pnpm root -g to get the global directory.
                pnpm_global="$(pnpm root -g)"
                [[ -d "$pnpm_global" ]] && dir "$pnpm_global"/*/
            fi
        fi
    fi

    if has pkgx && [[ -d "$HOME/.local/bin" ]]; then
        # https://github.com/pkgxdev/pkgx/issues/985#issuecomment-2080999008
        _pkgxpkgs="$(grep -rIhoP 'exec pkgx \+\K[^ ]+' "$HOME/.local/bin" | sort -u)"
        tot echo "$_pkgxpkgs"
        unset _pkgxpkgs
    fi

    # OS-specific package managers.
    case $os in
        Linux|BSD|"iPhone OS"|Solaris|illumos|Interix)
            # Package Manager Programs.
            has kiss       && tot kiss l
            has cpt-list   && tot cpt-list
            has pacman-key && tot pacman -Qq --color never
            has click      && tot click list
            has dpkg       && tot dpkg-query -f '.\n' -W
            has xbps-query && tot xbps-query -l
            has apk        && tot apk info
            has opkg       && tot opkg list-installed
            has pacman-g2  && tot pacman-g2 -Q
            has lvu        && tot lvu installed
            has tce-status && tot tce-status -i
            has pkg_info   && tot pkg_info
            has pkgin      && tot pkgin list
            has tazpkg     && pkgs_h=6 tot tazpkg list && ((packages-=6))
            has sorcery    && tot gaze installed
            has alps       && tot alps showinstalled
            has butch      && tot butch list
            has swupd      && tot swupd bundle-list --quiet
            has pisi       && tot pisi li
            has pacstall   && tot pacstall -L
            has bulge      && tot bulge list
            has pm         && tot-safe pm list packages
            has evox       && tot cat /var/evox/packages/DB
            has squirrel   && tot ls /var/packages
            has anise      && tot anise s --installed
            has am         && pac "$(am -f --less)"

            # Using the dnf package cache is much faster than rpm.
            if has dnf && type -p sqlite3 >/dev/null && [[ -f /var/cache/dnf/packages.db ]]; then
                pac "$(sqlite3 /var/cache/dnf/packages.db "SELECT count(pkg) FROM installed")"
            else
                has rpm && tot rpm -qa
            fi

            # 'mine' conflicts with minesweeper games.
            [[ -f /etc/SDE-VERSION ]] &&
                has mine && tot mine -q

            # Counting files/dirs.
            # Variables need to be unquoted here. Only Bedrock Linux is affected.
            # $br_prefix is fixed and won't change based on user input so this is safe either way.
            # shellcheck disable=SC2086
            {
            shopt -s nullglob
            has brew    && dir "$(brew --cellar)/* $(brew --caskroom)/*"
            has emerge  && dir "/var/db/pkg/*/*"
            has Compile && dir "/Programs/*/"
            has eopkg   && dir "/var/lib/eopkg/package/*"
            has inary   && dir "/var/lib/inary/package/*"
            has tekel   && dir "/data/app/$USER/* /data/app/system/*"
            has crew    && dir "${CREW_PREFIX:-/usr/local}/etc/crew/meta/*.filelist"
            has pkgtool && dir "/var/log/packages/*"
            has scratch && dir "/var/lib/scratchpkg/db/*"
            has kagami  && dir "/var/lib/kagami/pkgs/*"
            has cave    && dir "/var/db/paludis/repositories/cross-installed/*/data/*/ \
                               /var/db/paludis/repositories/installed/data/*/"
            has hardman && dir "/var/hpkg/packages/*"
            shopt -u nullglob
            }

            if [[ -z "$package_minimal" ]]; then
                # Steam games
                STEAM_P=".local/share/Steam/steamapps/common"
                if [[ -d "$HOME/$STEAM_P" ]]; then
                    manager=steam && dir "$HOME/$STEAM_P/*/"
                elif [[ -d "$HOME/.var/app/com.valvesoftware.Steam/$STEAM_P" ]]; then
                    manager=steam && dir "$HOME/.var/app/com.valvesoftware.Steam/$STEAM_P/*/"
                elif [[ -d "$HOME/.steam/steam/steamapps/common" ]]; then
                    manager=steam && dir "$HOME/.steam/steam/steamapps/common/*/"
                fi
            fi

            # Other (Needs complex command)
            has kpm-pkg && ((packages+=$(kpm  --get-selections | grep -cv deinstall$)))

            nix-user-pkgs() {
                if [ -d ~/.nix-profile ]; then
                    nix-store -qR ~/.nix-profile
                elif [ -d "$XDG_STATE_HOME/nix/profile" ]; then
                    nix-store -qR "$XDG_STATE_HOME/nix/profile"
                fi
                nix-store -qR /etc/profiles/per-user/"$USER"
            }

            # Separate system and user packages
            if [[ $package_separate == on ]]; then
                has guix && {
                    manager=guix-system && tot guix package -p /run/current-system/profile -I
                    manager=guix-user   && tot guix package -I
                    manager=guix-home   && tot guix package -p ~/.guix-home/profile -I
                }

                has nix-store && {
                    manager=nix-system  && tot nix-store -qR /run/current-system/sw
                    manager=nix-user    && tot nix-user-pkgs
                    manager=nix-default && tot nix-store -qR /nix/var/nix/profiles/default
                }

                has flatpak && {
                    manager=flatpak-system  && tot flatpak list --system
                    manager=flatpak-user    && tot flatpak list --user
                }
            else
                has guix && {
                    guix-all() {
                        guix package -p /run/current-system/profile -I
                        guix package -I
                        guix package -p ~/.guix-home/profile -I
                    }
                    manager=guix && tot guix-all
                }

                has nix-store && {
                    nix-all() {
                        nix-user-pkgs
                        nix-store -qR /run/current-system/sw
                        nix-store -qR /nix/var/nix/profiles/default
                    }
                    manager=nix && tot nix-all
                }

                has flatpak && {
                    manager=flatpak && tot flatpak list
                }
            fi

            # pkginfo is also the name of a python package manager which is painfully slow.
            # TODO: Fix this somehow.
            has pkginfo && tot pkginfo -i

            case $os-$kernel_name in
                BSD-FreeBSD|BSD-DragonFly)
                    has pkg && tot pkg info </dev/null
                ;;

                BSD-*)
                    has pkg && dir /var/db/pkg/*

                    ((packages == 0)) &&
                        has pkg && tot pkg list
                ;;

                illumos-*)
                    has pkg && tot pkg list
                ;;
            esac

            # List these last as they accompany regular package managers.
            has spm     && tot spm list -i
            has puyo    && dir ~/.puyo/installed

            # Snap hangs if the command is run without the daemon running.
            # Only run snap if the daemon is also running.
            has snap && ps -e | grep -qFm 1 snapd >/dev/null && \
            pkgs_h=1 tot snap list && ((packages-=1))

            # This is the only standard location for appimages.
            # See: https://github.com/AppImage/AppImageKit/wiki
            manager=appimage && has appimaged && dir ~/.local/bin/*.[Aa]pp[Ii]mage

            # Has devbox & is initialized
            has devbox && [[ "$(devbox global list)" != *"not activated"* ]] && tot devbox global list
        ;;

        "Mac OS X"|"macOS"|MINIX)
            has port  && pkgs_h=1 tot port installed && ((packages-=1))
            has brew  && dir "$(brew --cellar)/* $(brew --caskroom)/*"
            has pkgin && tot pkgin list
            has dpkg  && tot dpkg-query -f '.\n' -W

            has nix-store && {
                nix-user-pkgs() {
                    nix-store -qR ~/.nix-profile
                    nix-store -qR /etc/profiles/per-user/"$USER"
                }
                manager=nix-system && tot nix-store -qR /run/current-system/sw
                manager=nix-user   && tot nix-user-pkgs
            }
        ;;

        AIX|FreeMiNT)
            has lslpp && ((packages+=$(lslpp -J -l -q | grep -cv '^#')))
            has rpm   && tot rpm -qa
        ;;

        Windows)
            case $kernel_name in
                CYGWIN*) has cygcheck && tot cygcheck -cd ;;
                MSYS*)   has pacman   && tot pacman -Qq --color never ;;
            esac

            ProgramData=$(cygpath --folder 0x0023 2>/dev/null)
            if [[ -z "$ProgramData" ]]; then
                mount=$(awk '/^C:\s/ {print $2}' /proc/mounts 2>/dev/null)
                ProgramData="${mount:-/cygdrive/c}/ProgramData"
            fi

            # scoop list adds a few extra lines to be fancy, an easy fix is to just remove the first 4 lines. I dont know a better way to do this.
            has scoop && pkgs_h=4 tot scoop list

            # Count chocolatey packages.
            # [[ -d /c/ProgramData/chocolatey/lib ]] && \
            #     dir /c/ProgramData/chocolatey/lib/*
            # has choco && tot choco list --localonly
            has choco && dir "$ProgramData"/chocolatey/lib/*

            # Count winget
            has winget && tot winget list --accept-source-agreements
        ;;

        Haiku)
            has pkgman && dir /boot/system/package-links/*
            packages=${packages/pkgman/depot}
        ;;

        IRIX)
            manager=swpkg
            pkgs_h=3 tot versions -b && ((packages-=3))
        ;;
    esac

    if ((packages == 0)); then
        unset packages

    elif [[ $package_managers == on ]]; then
        printf -v packages '%s, ' "${managers[@]}"
        packages=${packages%,*}

    elif [[ $package_managers == tiny ]]; then
        packages+=" (${manager_string%,*})"
    fi

    packages=${packages/pacman-key/pacman}
}

get_shell() {
    case $shell_path in
        on)  shell="$SHELL " ;;
        off) shell="${SHELL##*/} " ;;
    esac

    [[ $shell_version != on ]] && return

    case ${shell_name:=${SHELL##*/}} in
        bash)
            [[ $BASH_VERSION ]] ||
                BASH_VERSION=$("$SHELL" -c "printf %s \"\$BASH_VERSION\"")

            shell+=${BASH_VERSION/-*}
        ;;

        sh|ash|dash|es) ;;

        *ksh)
            shell+=$("$SHELL" -c "printf %s \"\$KSH_VERSION\"")
            shell=${shell/ * KSH}
            shell=${shell/version}
        ;;

        osh)
            if [[ $OIL_VERSION ]]; then
                shell+=$OIL_VERSION
            else
                shell+=$("$SHELL" -c "printf %s \"\$OIL_VERSION\"")
            fi
        ;;

        tcsh)
            shell+=$("$SHELL" -c "printf %s \$tcsh")
        ;;

        yash)
            shell+=$("$SHELL" --version 2>&1)
            shell=${shell/ $shell_name}
            shell=${shell/ Yet another shell}
            shell=${shell/Copyright*}
        ;;

        nu)
            shell+=$("$SHELL" -c "version | get version")
            shell=${shell/ $shell_name}
        ;;


        *)
            shell+=$("$SHELL" --version 2>&1)
            shell=${shell/ $shell_name}
        ;;
    esac

    # Remove unwanted info.
    shell=${shell/, version}
    shell=${shell/xonsh\//xonsh }
    shell=${shell/options*}
    shell=${shell/\(*\)}
}

get_editor() {
    local editor_full_path="${VISUAL:-$EDITOR}"

    # in case neither is set just return
    [[ -z "$editor_full_path" ]] && return

    # Actually obtain the full path
    editor_full_path="$(command -v "${editor_full_path}" 2>/dev/null)"

    # Resolve symlink and get the original name
    [[ -L "$editor_full_path" ]] && editor_full_path="$(readlink -f "$editor_full_path")"

    case $editor_path in
        on)  editor="${editor_full_path} " ;;
        off) editor="${editor_full_path##*/} " ;;
    esac

    # in case editor version is not demanded don't bother parsing it
    [[ $editor_version != on ]] && return

    # Obtain editor version
    case ${editor_name:=${editor_full_path##*/}} in
        nano|vim|nvim|micro|emacs)
            editor_v=$("$editor_full_path" --version 2>&1)
        ;;
        kak)
            editor_v=$("$editor_full_path" -version 2>&1)
        ;;
        ne)
            editor_v=$("$editor_full_path" -h 2>&1)
        ;;
    esac
    editor_v="${editor_v/$'\n'*}"
    editor_v="${editor_v/Version: }"

    # Only show editor name if the version string doesn't contain it
    echo "$editor_v" | grep -i "$editor_name" &> /dev/null && editor_name=""
    editor=${editor_name}${editor_v:+ }${editor_v}

    # remove some common unwanted info from version strings
    editor=${editor/, version}
    editor=${editor/options*}
    editor=${editor/\(*\)}
}

get_de() {
    # If function was run, stop here.
    ((de_run == 1)) && return

    case $os in
        "Mac OS X"|"macOS") de=Aqua ;;

        "ravynOS") de=Magma ;;

        Windows)
            case $distro in
                *"Windows 10"*|*"Windows 11"*)
                    de=Fluent
                ;;

                *"Windows 8"*)
                    de=Metro
                ;;

                *)
                    de=Aero
                ;;
            esac
        ;;

        FreeMiNT)
            freemint_wm=(/proc/*)

            case ${freemint_wm[*]} in
                *thing*)  de=Thing ;;
                *jinnee*) de=Jinnee ;;
                *tera*)   de=Teradesk ;;
                *neod*)   de=NeoDesk ;;
                *zdesk*)  de=zDesk ;;
                *mdesk*)  de=mDesk ;;
            esac
        ;;

        *)
            ((wm_run != 1)) && get_wm

            # Temporary support for Regolith Linux
            if [[ $DESKTOP_SESSION == *regolith ]]; then
                de=Regolith

            # Added support Fly for Astra Linux
            elif [[ $DESKTOP_SESSION == fly ]]; then
                de=Fly

            elif [[ $XDG_CURRENT_DESKTOP ]]; then
                de=${XDG_CURRENT_DESKTOP/X\-}
                de=${de/Budgie:GNOME/Budgie}
                de=${de/:Unity7:ubuntu}

            elif [[ $DESKTOP_SESSION ]]; then
                de=${DESKTOP_SESSION##*/}
                de=${de/trinity/Trinity}

            elif [[ $GNOME_DESKTOP_SESSION_ID ]]; then
                de=GNOME

            elif [[ $MATE_DESKTOP_SESSION_ID ]]; then
                de=MATE

            elif [[ $TDE_FULL_SESSION ]]; then
                de=Trinity
            fi

            # When a window manager is started from a display manager
            # the desktop variables are sometimes also set to the
            # window manager name. This checks to see if WM == DE
            # and discards the DE value.
            [[ $de == "$wm" ]] && { unset -v de; return; }
        ;;
    esac

    # Fallback to using xprop.
    [[ $DISPLAY && -z $de ]] && type -p xprop &>/dev/null && \
        de=$(xprop -root | awk '/KDE_SESSION_VERSION|^_MUFFIN|xfce4|xfce5/')

    # Format strings.
    case $de in
        KDE_SESSION_VERSION*) de=KDE${de/* = } ;;
        *xfce4*)  de=Xfce4 ;;
        *xfce5*)  de=Xfce5 ;;
        *xfce*)   de=Xfce ;;
        *mate*)   de=MATE ;;
        *GNOME*)  de=GNOME ;;
        *MUFFIN*) de=Cinnamon ;;
    esac

    ((${KDE_SESSION_VERSION:-0} >= 4)) && de=${de/KDE/Plasma}
    ((${KDE_SESSION_VERSION:-0} >= 6)) && de=${de/Plasma/Plasma6}

    if [[ $de_version == on && $de ]]; then
        case $de in
            Plasma6*)
                       de_ver=$(plasmashell --version)
                       kf_ver=$(kinfo)
                       qt_ver=${kf_ver/Kernel*}
                       qt_ver=${qt_ver/*:}
                       qt_ver=$(trim "$qt_ver")
                       kf_ver=${kf_ver/Qt*}
                       kf_ver=${kf_ver/*:}
                       kf_ver=$(trim "$kf_ver")
            ;;
            Plasma*)
                       de_ver=$(plasmashell --version)
                       kf_ver=$(kf5-config --version)
                       qt_ver=${kf_ver/KDE*}
                       qt_ver=${qt_ver/Qt:}
                       qt_ver=$(trim "$qt_ver")
                       kf_ver=${kf_ver/kf5*}
                       kf_ver=${kf_ver/*:}
                       kf_ver=$(trim "$kf_ver")
            ;;
            MATE*)     de_ver=$(mate-session --version) ;;
            Xfce*)     de_ver=$(xfce4-session --version) ;;
            GNOME*)    de_ver=$(gnome-shell --version) ;;
            Cinnamon*) de_ver=$(cinnamon --version) ;;
            Deepin*)   de_ver=$(awk -F'=' '/MajorVersion/ {print $2}' /etc/os-version) ;;
            Budgie*)   de_ver=$(budgie-desktop --version) ;;
            Cutefish*) de_ver=$(awk -F'=' '/Version/ {print $2}' /etc/cutefish) ;;
            LXQt*)     de_ver=$(lxqt-session --version) ;;
            Lumina*)   de_ver=$(lumina-desktop --version 2>&1) ;;
            Trinity*)  de_ver=$(tde-config --version) ;;
            Unity*)    de_ver=$(unity --version) ;;
        esac

        de_ver=${de_ver/*TDE:}
        de_ver=${de_ver/tde-config*}
        de_ver=${de_ver/liblxqt*}
        de_ver=${de_ver/Copyright*}
        de_ver=${de_ver/)*}
        de_ver=${de_ver/* }
        de_ver=${de_ver//\"}

        de+=" $de_ver"

        [[ $de == "Plasma"* ]] && de="Plasma $de_ver [KF $kf_ver] [Qt $qt_ver]"
    fi

    # TODO:
    #  - New config option + flag: --de_display_server on/off ?
    #  - Add display of X11, Arcan and anything else relevant.
    [[ $de ]] && [[ -n $XDG_SESSION_TYPE ]] &&
        de+=" (${XDG_SESSION_TYPE})"

    de_run=1
}

get_wm() {
    # If function was run, stop here.
    ((wm_run == 1)) && return

    case $kernel_name in
        *OpenBSD*) ps_flags=(x -c) ;;
        *)         ps_flags=(-e) ;;
    esac

    if [[ -O "${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY:-wayland-0}" ]]; then
        if tmp_pid="$(lsof -t "${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY:-wayland-0}" 2>&1)" ||
           tmp_pid="$(fuser   "${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY:-wayland-0}" 2>&1)"; then
            tmp_pid="$(trim "${tmp_pid##*:}")"
            wm="$(ps -p "${tmp_pid}" -ho comm=)"
        else
            # lsof may not exist, or may need root on some systems. Similarly fuser.
            # On those systems we search for a list of known window managers, this can mistakenly
            # match processes for another user or session and will miss unlisted window managers.
            wm=$(ps "${ps_flags[@]}" | grep -m 1 -o -F \
                               -e ^arcan$ \
                               -e ^asc$ \
                               -e ^clayland$ \
                               -e ^dwc$ \
                               -e ^dwl$ \
                               -e ^fireplace$ \
                               -e ^gnome-shell$ \
                               -e ^greenfield$ \
                               -e ^grefsen$ \
                               -e ^hikari$ \
                               -e ^Hyprland$ \
                               -e ^kwin$ \
                               -e ^lipstick$ \
                               -e ^maynard$ \
                               -e ^mazecompositor$ \
                               -e ^motorcar$ \
                               -e ^orbital$ \
                               -e ^orbment$ \
                               -e ^perceptia$ \
                               -e ^river$ \
                               -e ^rustland$ \
                               -e ^sway$ \
                               -e ^ulubis$ \
                               -e ^velox$ \
                               -e ^wavy$ \
                               -e ^way-cooler$ \
                               -e ^wayfire$ \
                               -e ^wayhouse$ \
                               -e ^westeros$ \
                               -e ^westford$ \
                               -e ^weston$ )
        fi

    elif [[ $DISPLAY && $os != "Mac OS X" && $os != "macOS" && $os != FreeMiNT ]]; then
        # non-EWMH WMs.
        wm=$(ps "${ps_flags[@]}" | grep -m 1 -o \
                           -e "[s]owm" \
                           -e "[c]atwm" \
                           -e "[f]vwm" \
                           -e "[d]wm" \
                           -e "[2]bwm" \
                           -e "[m]onsterwm" \
                           -e "[t]inywm" \
                           -e "[x]11fs" \
                           -e "[x]monad")

        [[ -z $wm ]] && type -p xprop &>/dev/null && {
            id=$(xprop -root -notype _NET_SUPPORTING_WM_CHECK)
            id=${id##* }
            wm=$(xprop -id "$id" -notype -len 100 -f _NET_WM_NAME 8t)
            wm=${wm/*WM_NAME = }
            wm=${wm/\"}
            wm=${wm/\"*}
        }

    else
        case $os in
            "Mac OS X"|"macOS")
                ps_line=$(ps -e | grep -o \
                    -e "[S]pectacle" \
                    -e "[A]methyst" \
                    -e "[k]wm" \
                    -e "[c]hun[k]wm" \
                    -e "[y]abai" \
                    -e "[R]ectangle")

                case $ps_line in
                    *chunkwm*)   wm=chunkwm ;;
                    *kwm*)       wm=Kwm ;;
                    *yabai*)     wm=yabai ;;
                    *Amethyst*)  wm=Amethyst ;;
                    *Spectacle*) wm=Spectacle ;;
                    *Rectangle*) wm=Rectangle ;;
                    *)           wm="Quartz Compositor" ;;
                esac
            ;;

            Windows)
                wm=$(
                    tasklist |

                    grep -Fom 1 \
                         -e bugn \
                         -e Windawesome \
                         -e blackbox \
                         -e emerge \
                         -e litestep
                )

                [[ $wm == blackbox ]] &&
                    wm="bbLean (Blackbox)"

                wm=${wm:+$wm, }DWM.exe
            ;;

            FreeMiNT)
                freemint_wm=(/proc/*)

                case ${freemint_wm[*]} in
                    *xaaes* | *xaloader*) wm=XaAES ;;
                    *myaes*)              wm=MyAES ;;
                    *naes*)               wm=N.AES ;;
                    geneva)               wm=Geneva ;;
                    *)                    wm="Atari AES" ;;
                esac
            ;;
        esac
    fi

    # Rename window managers to their proper values.
    [[ $wm == *WINDOWMAKER* ]] && wm=wmaker
    [[ $wm == *GNOME*Shell* ]] && wm=Mutter

    wm_run=1
}

get_wm_theme() {
    ((wm_run != 1)) && get_wm
    ((de_run != 1)) && get_de

    case $wm  in
        E16)
            wm_theme=$(awk -F "= " '/theme.name/ {print $2}' "${HOME}/.e16/e_config--0.0.cfg")
        ;;

        Sawfish)
            wm_theme=$(awk -F '\\(quote|\\)' '/default-frame-style/ {print $(NF-4)}' \
                       "$HOME/.sawfish/custom")
        ;;

        Cinnamon|Muffin|"Mutter (Muffin)")
            detheme=$(gsettings get org.cinnamon.theme name)
            wm_theme=$(gsettings get org.cinnamon.desktop.wm.preferences theme)
            wm_theme="$detheme ($wm_theme)"
        ;;

        Compiz|Mutter|Gala)
            if type -p gsettings >/dev/null; then
                wm_theme=$(gsettings get org.gnome.shell.extensions.user-theme name)

                [[ ${wm_theme//\'} ]] || \
                    wm_theme=$(gsettings get org.gnome.desktop.wm.preferences theme)

            elif type -p gconftool-2 >/dev/null; then
                wm_theme=$(gconftool-2 -g /apps/metacity/general/theme)
            fi
        ;;

        Metacity*)
            if [[ $de == Deepin ]]; then
                wm_theme=$(gsettings get com.deepin.wrap.gnome.desktop.wm.preferences theme)

            elif [[ $de == MATE ]]; then
                wm_theme=$(gsettings get org.mate.Marco.general theme)

            else
                wm_theme=$(gconftool-2 -g /apps/metacity/general/theme)
            fi
        ;;

        E17|Enlightenment)
            if type -p eet >/dev/null; then
                wm_theme=$(eet -d "$HOME/.e/e/config/standard/e.cfg" config |\
                            awk '/value \"file\" string.*.edj/ {print $4}')
                wm_theme=${wm_theme##*/}
                wm_theme=${wm_theme%.*}
            fi
        ;;

        Fluxbox)
            [[ -f $HOME/.fluxbox/init ]] &&
                wm_theme=$(awk -F "/" '/styleFile/ {print $NF}' "$HOME/.fluxbox/init")
        ;;

        IceWM*)
            [[ -f $HOME/.icewm/theme ]] &&
                wm_theme=$(awk -F "[\",/]" '!/#/ {print $2}' "$HOME/.icewm/theme")
        ;;

        Openbox)
            case $de in
                LXDE*) ob_file="lxde-rc" ;;
                LXQt*) ob_file="lxqt-rc" ;;
                    *) ob_file="rc" ;;
            esac

            ob_file=$XDG_CONFIG_HOME/openbox/$ob_file.xml

            [[ -f $ob_file ]] &&
                wm_theme=$(awk '/<theme>/ {while (getline n) {if (match(n, /<name>/))
                            {l=n; exit}}} END {split(l, a, "[<>]"); print a[3]}' "$ob_file")
        ;;

        PekWM)
            [[ -f $HOME/.pekwm/config ]] &&
                wm_theme=$(awk -F "/" '/Theme/{gsub(/\"/,""); print $NF}' "$HOME/.pekwm/config")
        ;;

        Xfwm4)
            [[ -f $HOME/.config/xfce4/xfconf/xfce-perchannel-xml/xfwm4.xml ]] &&
                wm_theme=$(xfconf-query -c xfwm4 -p /general/theme)
        ;;

        KWin*)
            kde_config_dir
            kwinrc=$kde_config_dir/kwinrc
            kdebugrc=$kde_config_dir/kdebugrc

            if [[ -f $kwinrc ]]; then
                wm_theme=$(awk '/theme=/ {
                                    gsub(/theme=.*qml_|theme=.*svg__/,"",$0);
                                    print $0;
                                    exit
                                 }' "$kwinrc")

                [[ "$wm_theme" ]] ||
                    wm_theme=$(awk '/library=org.kde/ {
                                        gsub(/library=org.kde./,"",$0);
                                        print $0;
                                        exit
                                     }' "$kwinrc")

                [[ $wm_theme ]] ||
                    wm_theme=$(awk '/PluginLib=kwin3_/ {
                                        gsub(/PluginLib=kwin3_/,"",$0);
                                        print $0;
                                        exit
                                     }' "$kwinrc")

            elif [[ -f $kdebugrc ]]; then
                wm_theme=$(awk '/(decoration)/ {gsub(/\[/,"",$1); print $1; exit}' "$kdebugrc")
            fi

            wm_theme=${wm_theme/theme=}
        ;;

        "Quartz Compositor")
            global_preferences=$HOME/Library/Preferences/.GlobalPreferences.plist
            wm_theme=$(PlistBuddy -c "Print AppleInterfaceStyle" "$global_preferences")
            wm_theme_color=$(PlistBuddy -c "Print AppleAccentColor" "$global_preferences")

            [[ "$wm_theme" ]] ||
                wm_theme=Light

            case $wm_theme_color in
                -1) wm_theme_color=Graphite ;;
                0)  wm_theme_color=Red ;;
                1)  wm_theme_color=Orange ;;
                2)  wm_theme_color=Yellow ;;
                3)  wm_theme_color=Green ;;
                5)  wm_theme_color=Purple ;;
                6)  wm_theme_color=Pink ;;
                *)  wm_theme_color=Blue ;;
            esac

            wm_theme="$wm_theme_color ($wm_theme)"
        ;;

        *Explorer)
            path=/proc/registry/HKEY_CURRENT_USER/Software/Microsoft
            path+=/Windows/CurrentVersion/Themes/CurrentTheme

            wm_theme=$(head -n1 "$path")
            wm_theme=${wm_theme##*\\}
            wm_theme=${wm_theme%.*}
        ;;

        Blackbox|bbLean*)
            path=$(wmic process get ExecutablePath | grep -F "blackbox")
            path=${path//\\/\/}

            wm_theme=$(grep '^session\.styleFile:' "${path/\.exe/.rc}")
            wm_theme=${wm_theme/session\.styleFile: }
            wm_theme=${wm_theme##*\\}
            wm_theme=${wm_theme%.*}
        ;;

        LeftWM*)
            if command -v leftwm-theme &> /dev/null
            then
                wm_theme=$(leftwm-theme status | grep "Your current theme" | sed -e 's/Your current theme is //g' -e 's/\,.*$//g')
            fi
        ;;

        fly-wm)
            fly_config_file
            if grep -q 'DecorTheme' "${fly_config_file}" 2>/dev/null; then
                wm_theme=$(awk -F'=' '/^DecorTheme/{print $2}' "${fly_config_file}")
            fi
            if [ -z "$wm_theme" ] || [ "$wm_theme" = "Not Found" ]; then
                wm_theme=Default
            fi
        ;;
    esac

    wm_theme=$(trim_quotes "$wm_theme")
}

get_cpu() {
    case $os in
        "Ironclad")
            cpu="$(cpuinfo -n) ($(cpuinfo -c)) @ $(cpuinfo -f)"
            ;;
        "Linux" | "MINIX" | "Windows")
            # Get CPU name.
            cpu_file="/proc/cpuinfo"

            case $kernel_machine in
                "frv" | "hppa" | "m68k" | "openrisc" | "or"* | "powerpc" | "ppc"* | "sparc"*)
                    cpu="$(awk -F':' '/^cpu\t|^CPU/ {printf $2; exit}' "$cpu_file")"
                ;;

                "s390"*)
                    cpu="$(awk -F'=' '/machine/ {print $4; exit}' "$cpu_file")"
                ;;

                "ia64" | "m32r")
                    cpu="$(awk -F':' '/model/ {print $2; exit}' "$cpu_file")"
                    [[ -z "$cpu" ]] && cpu="$(awk -F':' '/family/ {printf $2; exit}' "$cpu_file")"
                ;;

                "riscv"* | "rv"*)
                    cpu_uarch="$(awk -F':' '/uarch/ {print $2; exit}' "$cpu_file")"
                    # RISC-V ISA string example: "rv64imafdch_zicsr_zifencei".
                    cpu_isa="$(awk -F':' '/isa/ {print $2; exit}' "$cpu_file")"
                    # The _z parts are not important for CPU showcasing, so we remove them.
                    cpu_isa="${cpu_isa%%_*}"
                    # Then we replace "imafd" with "g" since "g" is a shorthand.
                    cpu_isa="${cpu_isa/imafd/g}"
                    # The final ISA output of the above example is "rv64gch".
                    cpu="$cpu_uarch $cpu_isa"
                ;;

                "arm"* | "aarch64")
                    if [[ $(trim "$distro") == Android* ]]; then
                        # Android roms have modified cpuinfo that shows CPU model as a string
                        cpu="$(awk -F':' '/Hardware/ {print $2; exit}' "$cpu_file")"
                    else
                        # ARM linux displays binary model code in cpuinfo, which needs to be decoded with lscpu
                        if ! command -v python3 &> /dev/null; then
                            cpu="$(lscpu | awk -F': ' '/Vendor ID/ {print $2; exit}' ) $(lscpu | awk -F': ' '/Model name/ {print $2; exit}')"
                        else
                            # Sometimes there are multiple CPU models (e.g. RK3399 has 4 A53 and 2 A72 cores)
                            # However, I don't know how to implement this in awk, so I'll use python for now
                            read -r -d '' py_script << END
from subprocess import check_output


def find(lines, label):
    for ln in lines:
        if ln.strip().startswith(label):
            t = ln.split(label)[-1].strip()
            return None if t == '-' else t

    return None


if __name__ == '__main__':
    lscpu = check_output('lscpu').decode()

    vendor_id = find(lscpu.split('\n'), 'Vendor ID:') or None

    cpus = []

    for model_desc in lscpu.split('Model name:'):
        lines = model_desc.split('\n')
        model = lines[0].strip()

        cores = find(lines, 'Core(s) per socket:') or find(lines, 'Core(s) per cluster:')
        if cores is None:
            continue

        cores = int(cores)
        cores *= int(find(lines, 'Socket(s):') or find(lines, 'Cluster(s):') or "1")
        if cores == -1:
            continue

        mhz = float(find(lines, 'CPU max MHz:') or find(lines, 'CPU min MHz:') or "0")
        speed = f'@ {mhz / 1000:.2f} GHz' if mhz > 0 else ''

        cpus.append(f'{vendor_id} {model} ({cores}) {speed}')

    print('\n'.join(cpus))
END
                            tmp_cpus=$(python3 -c "$py_script")
                            while IFS= read -r line; do
                                prin "${subtitle:+${subtitle}}" "$line"
                            done <<< "$tmp_cpus"

                            return
                        fi
                    fi
                ;;
            esac

            # If cpu is not detected on a platform-specific bases, fallback to cpuinfo method
            [[ -z "$cpu" ]] && cpu="$(awk -F '\\s*: | @' '/model name|Model|uarch|Hardware|Processor|^cpu model|chip type|^cpu type/ { print $2; exit}' "$cpu_file")"
            [[ -z "$cpu" ]] && cpu="$(awk -F '\\s*: | @' '/Hardware/ {print $2; exit}' "$cpu_file")"

            speed_dir="/sys/devices/system/cpu/cpu0/cpufreq"

            # Select the right temperature file.
            for temp_dir in /sys/class/hwmon/*; do
                [[ "$(< "${temp_dir}/name")" =~ (cpu_thermal|coretemp|fam15h_power|k10temp) ]] && {
                    temp_dirs=("$temp_dir"/temp*_input)
                    temp_dir=${temp_dirs[0]}
                    break
                }
            done

            # If on a Raspberry Pi...
            if grep -q "Raspberry Pi" /proc/device-tree/model; then
                temp_dir=/sys/class/thermal/thermal_zone0/temp
            fi

            # Get CPU speed.
            if [[ -d "$speed_dir" ]]; then
                # Fallback to bios_limit if $speed_type fails.
                speed="$(< "${speed_dir}/${speed_type}")" ||\
                speed="$(< "${speed_dir}/bios_limit")" ||\
                speed="$(< "${speed_dir}/scaling_max_freq")" ||\
                speed="$(< "${speed_dir}/cpuinfo_max_freq")"
                speed="$((speed / 1000))"

            else
                case $kernel_machine in
                    "sparc"*)
                        # SPARC systems use a different file to expose clock speed information.
                        speed_file="/sys/devices/system/cpu/cpu0/clock_tick"
                        speed="$(($(< "$speed_file") / 1000000))"
                    ;;

                    *)
                        speed="$(awk -F ': |\\.' '/cpu MHz|^clock/ {printf $2; exit}' "$cpu_file")"
                        speed="${speed/MHz}"
                    ;;
                esac
            fi

            # Get CPU temp.
            [[ -f "$temp_dir" ]] && deg="$(($(< "$temp_dir") * 100 / 10000))"

            # Get CPU cores.
            case $kernel_machine in
                "sparc"*)
                    case $cpu_cores in
                        # SPARC systems doesn't expose detailed topology information in
                        # /proc/cpuinfo so I have to use lscpu here.
                        "logical" | "on")
                            cores="$(lscpu | awk -F ': *' '/^CPU\(s\)/ {print $2}')"
                        ;;
                        "physical")
                            cores="$(lscpu | awk -F ': *' '/^Core\(s\) per socket/ {print $2}')"
                            sockets="$(lscpu | awk -F ': *' '/^Socket\(s\)/ {print $2}')"
                            cores="$((sockets * cores))"
                        ;;
                    esac
                ;;

                *)
                    sockets="$(grep "physical id" /proc/cpuinfo | sort -u | wc -l)"

                    case $cpu_cores in
                        "logical" | "on")
                            cores="$(grep -c "^processor" "$cpu_file")"
                        ;;
                        "physical")
                            cores="$(awk '/^core id/&&!a[$0]++{++i} END {print i}' "$cpu_file")"
                        ;;
                    esac
                ;;
            esac
        ;;

        "Mac OS X"|"macOS")
            if [[ $osx_version == 10.[4-5]* ]]; then
                cpu="$(system_profiler SPHardwareDataType | grep CPU\ Type)"
                cpu="${cpu/CPU\ Type\:/}"

                speed="$(system_profiler SPHardwareDataType | grep CPU\ Speed)"
                speed="${speed/CPU\ Speed\:/}"
                speed="${speed/ MHz/}"
                speed="${speed/ GHz/}"

                cores="$(system_profiler SPHardwareDataType | grep Number\ Of\ CPUs)"
                cores="${cores/Number\ Of\ CPUs\:/}"
            else
                cpu="$(sysctl -n machdep.cpu.brand_string)"
            fi

            # Get CPU cores.
            case $cpu_cores in
                "logical" | "on") cores="$(sysctl -n hw.logicalcpu_max)" ;;
                "physical")       cores="$(sysctl -n hw.physicalcpu_max)" ;;
            esac
        ;;

        "iPhone OS")
            case $kernel_machine in
                "iPhone1,"[1-2] | "iPod1,1"): "Samsung S5L8900 (1) @ 412MHz" ;;
                "iPhone2,1"):                 "Samsung S5PC100 (1) @ 600MHz" ;;
                "iPhone3,"[1-3] | "iPod4,1"): "Apple A4 (1) @ 800MHz" ;;
                "iPhone4,1" | "iPod5,1"):     "Apple A5 (2) @ 800MHz" ;;
                "iPhone5,"[1-4]): "Apple A6 (2) @ 1.3GHz" ;;
                "iPhone6,"[1-2]): "Apple A7 (2) @ 1.3GHz" ;;
                "iPhone7,"[1-2]): "Apple A8 (2) @ 1.4GHz" ;;
                "iPhone8,"[1-4] | "iPad6,1"[12]): "Apple A9 (2) @ 1.85GHz" ;;
                "iPhone9,"[1-4] | "iPad7,"[5-6] | "iPad7,1"[1-2]):
                    "Apple A10 Fusion (4) @ 2.34GHz"
                ;;
                "iPhone10,"[1-6]): "Apple A11 Bionic (6) @ 2.39GHz" ;;
                "iPhone11,"[2468] | "iPad11,"[1-4] | "iPad11,"[6-7]): "Apple A12 Bionic (6) @ 2.49GHz" ;;
                "iPhone12,"[1358]): "Apple A13 Bionic (6) @ 2.65GHz" ;;
                "iPhone13,"[1-4] | "iPad13,"[1-2]): "Apple A14 Bionic (6) @ 3.00GHz" ;;
                "iPhone14,"[2-8]): "Apple A15 Bionic (6) @ 3.23GHz" ;;
                "iPhone15,"[2-3]): "Apple A16 Bionic (6) @ 3.46GHz" ;;
                "iPad12,"[1-2]): "Apple A13 Bionic (6) @ 2.65GHz" ;;
                "iPad13,"[4-9]): "Apple M1 (8) @ 3.19GHz" ;;
                "iPad13,1"[0-1]): "Apple M1 (8) @ 3.19GHz" ;;
                "iPad13,1"[6-7]): "Apple M1 (8) @ 3.19GHz" ;;
                "iPad13,1"[8-9]): "Apple A14 Bionic (6) @ 3.00GHz" ;;
                "iPad14,"[1-2]): "Apple A15 Bionic (6) @ 3.23GHz" ;;
                "iPad14,"[3-6]): "Apple M2 (8) @ 3.49GHz" ;;

                "iPod2,1"): "Samsung S5L8720 (1) @ 533MHz" ;;
                "iPod3,1"): "Samsung S5L8922 (1) @ 600MHz" ;;
                "iPod7,1"): "Apple A8 (2) @ 1.1GHz" ;;
                "iPod9,1"): "Apple A10 Fusion (4) @ 1.64GHz" ;;
                "iPad1,"[1-2]): "Apple A4 (1) @ 1GHz" ;;
                "iPad2,"[1-7]): "Apple A5 (2) @ 1GHz" ;;
                "iPad3,"[1-3]): "Apple A5X (2) @ 1GHz" ;;
                "iPad3,"[4-6]): "Apple A6X (2) @ 1.4GHz" ;;
                "iPad4,"[1-3]): "Apple A7 (2) @ 1.4GHz" ;;
                "iPad4,"[4-9]): "Apple A7 (2) @ 1.4GHz" ;;
                "iPad5,"[1-2]): "Apple A8 (2) @ 1.5GHz" ;;
                "iPad5,"[3-4]): "Apple A8X (3) @ 1.5GHz" ;;
                "iPad6,"[3-4]): "Apple A9X (2) @ 2.16GHz" ;;
                "iPad6,"[7-8]): "Apple A9X (2) @ 2.26GHz" ;;
                "iPad7,"[1-4]): "Apple A10X Fusion (6) @ 2.39GHz" ;;
                "iPad8,"[1-8]): "Apple A12X Bionic (8) @ 2.49GHz" ;;
                "iPad8,9" | "iPad8,1"[0-2]): "Apple A12Z Bionic (8) @ 2.49GHz" ;;
            esac
            cpu="$_"
        ;;

        "BSD")
            # Get CPU name.
            cpu="$(sysctl -n hw.model)"
            cpu="${cpu/[0-9]\.*}"
            cpu="${cpu/ @*}"

            # Get CPU speed.
            speed="$(sysctl -n hw.cpuspeed)"
            [[ -z "$speed" ]] && speed="$(sysctl -n  hw.clockrate)"

            # Get CPU cores.
            case $kernel_name in
                "OpenBSD"*)
                    [[ "$(sysctl -n hw.smt)" == "1" ]] && smt="on" || smt="off"
                    ncpufound="$(sysctl -n hw.ncpufound)"
                    ncpuonline="$(sysctl -n hw.ncpuonline)"
                    cores="${ncpuonline}/${ncpufound},\\xc2\\xa0SMT\\xc2\\xa0${smt}"
                ;;
                *)
                    cores="$(sysctl -n hw.ncpu)"
                ;;
            esac

            # Get CPU temp.
            case $kernel_name in
                "FreeBSD"* | "DragonFly"* | "NetBSD"*)
                    deg="$(sysctl -n dev.cpu.0.temperature)"
                    deg="${deg/C}"
                ;;
                "OpenBSD"* | "Bitrig"*)
                    deg="$(sysctl hw.sensors | \
                        awk -F'=|degC' '/(ksmn|adt|lm|cpu)0.temp0/ {printf("%2.1f", $2); exit}')"
                ;;
            esac
        ;;

        "Solaris" | "illumos")
            # Get CPU name.
            cpu="$(psrinfo -pv)"
            cpu="${cpu//*$'\n'}"
            cpu="${cpu/[0-9]\.*}"
            cpu="${cpu/ @*}"
            cpu="${cpu/\(portid*}"

            # Get CPU speed.
            speed="$(psrinfo -v | awk '/operates at/ {print $6; exit}')"

            # Get CPU cores.
            case $cpu_cores in
                "logical" | "on") cores="$(kstat -m cpu_info | grep -c -F "chip_id")" ;;
                "physical") cores="$(psrinfo -p)" ;;
            esac
        ;;

        "Haiku")
            # Get CPU name.
            cpu="$(sysinfo -cpu | awk -F '\\"' '/CPU #0/ {print $2}')"
            cpu="${cpu/@*}"

            # Get CPU speed.
            speed="$(sysinfo -cpu | awk '/running at/ {print $NF; exit}')"
            speed="${speed/MHz}"

            # Get CPU cores.
            cores="$(sysinfo -cpu | grep -c -F 'CPU #')"
        ;;

        "AIX")
            # Get CPU name.
            cpu="$(lsattr -El proc0 -a type | awk '{printf $2}')"

            # Get CPU speed.
            speed="$(prtconf -s | awk -F':' '{printf $2}')"
            speed="${speed/MHz}"

            # Get CPU cores.
            case $cpu_cores in
                "logical" | "on")
                    cores="$(lparstat -i | awk -F':' '/Online Virtual CPUs/ {printf $2}')"
                ;;

                "physical")
                    cores="$(lparstat -i | awk -F':' '/Active Physical CPUs/ {printf $2}')"
                ;;
            esac
        ;;

        "IRIX")
            # Get CPU name.
            cpu="$(hinv -c processor | awk -F':' '/CPU:/ {printf $2}')"

            # Get CPU speed.
            speed="$(hinv -c processor | awk '/MHZ/ {printf $2}')"

            # Get CPU cores.
            cores="$(sysconf NPROC_ONLN)"
        ;;

        "FreeMiNT")
            cpu="$(awk -F':' '/CPU:/ {printf $2}' /kern/cpuinfo)"
            speed="$(awk -F '[:.M]' '/Clocking:/ {printf $2}' /kern/cpuinfo)"
        ;;

        "Interix")
            cpu="$(/dev/fs/C/Windows/System32/wbem/WMIC.exe cpu get Name)"
            cpu="${cpu/Name}"

            speed="$(/dev/fs/C/Windows/System32/wbem/WMIC.exe cpu get CurrentClockSpeed)"
            speed="${speed/CurrentClockSpeed}"

            cores="$(/dev/fs/C/Windows/System32/wbem/WMIC.exe cpu get NumberOfCores)"
            cores="${cores/NumberOfCores}"
        ;;
    esac

    # Remove un-needed patterns from cpu output.
    cpu="${cpu//(TM)}"
    cpu="${cpu//(tm)}"
    cpu="${cpu//(R)}"
    cpu="${cpu//(r)}"
    cpu="${cpu//CPU}"
    cpu="${cpu//Processor}"
    cpu="${cpu//Dual-Core}"
    cpu="${cpu//Quad-Core}"
    cpu="${cpu//Six-Core}"
    cpu="${cpu//Eight-Core}"
    cpu="${cpu//[1-9][0-9]-Core}"
    cpu="${cpu//[0-9]-Core}"
    cpu="${cpu//, * Compute Cores}"
    cpu="${cpu//Core / }"
    cpu="${cpu//(\"AuthenticAMD\"*)}"
    cpu="${cpu//with Radeon*Graphics}"
    cpu="${cpu//, altivec supported}"
    cpu="${cpu//FPU*}"
    cpu="${cpu//Chip Revision*}"
    cpu="${cpu//Technologies, Inc}"
    cpu="${cpu//Core2/Core 2}"

    # Trim spaces from core and speed output
    cores="${cores//[[:space:]]}"
    speed="${speed//[[:space:]]}"

    # Remove CPU brand from the output.
    if [[ "$cpu_brand" == "off" ]]; then
        cpu="${cpu/AMD }"
        cpu="${cpu/Intel }"
        cpu="${cpu/Core? Duo }"
        cpu="${cpu/Qualcomm }"
    fi

    # Add CPU cores to the output.
    [[ "$cpu_cores" != "off" && "$cores" ]] && \
        case $os in
            "Mac OS X"|"macOS")
                if [[ $(uname -m) == 'arm64' ]]; then
                    cpu="$cpu ($cores)"
                else
                    cpu="${cpu/@/(${cores}) @}"
                fi
            ;;
            *)
                # If socket information is present and more than 1, display cpu count first
                if [[ $sockets ]] && [[ $sockets -gt 1 ]]; then
                    cpu="${sockets}x $cpu ($((cores / sockets)))"
                else
                    cpu="$cpu ($cores)"
                fi
            ;;
        esac

    # Add CPU speed to the output.
    if [[ "$cpu_speed" != "off" && "$speed" ]]; then
        if (( speed < 1000 )); then
            cpu="$cpu @ ${speed}MHz"
        else
            [[ "$speed_shorthand" == "on" ]] && speed="$((speed / 100))"
            speed="${speed:0:1}.${speed:1}"
            cpu="$cpu @ ${speed}GHz"
        fi
    fi

    # Add CPU temp to the output.
    if [[ "$cpu_temp" != "off" && "$deg" ]]; then
        deg="${deg//.}"

        # Convert to Fahrenheit if enabled
        [[ "$cpu_temp" == "F" ]] && deg="$((deg * 90 / 50 + 320))"

        # Format the output
        deg="[${deg/${deg: -1}}.${deg: -1}°${cpu_temp:-C}]"
        cpu="$cpu $deg"
    fi
}

get_gpu() {
    case $os in
        "Linux")
            # Read GPUs into array.
            gpu_cmd="$(lspci -mm |
                       awk -F '\"|\" \"|\\(' \
                              '/"Display|"3D|"VGA/ {
                                  a[$0] = $1 " " $3 " " ($(NF-1) ~ /^$|^Device [[:xdigit:]]+$/ ? $4 : $(NF-1))
                              }
                              END { for (i in a) {
                                  if (!seen[a[i]]++) {
                                      sub("^[^ ]+ ", "", a[i]);
                                      print a[i]
                                  }
                              }}')"

            if [[ "$gpu_cmd" == "" ]]; then
                gpu_cmd="$(glxinfo -B | grep -F 'OpenGL renderer string')"
                gpu_cmd="${gpu_cmd/OpenGL renderer string: }"
            fi

            IFS=$'\n' read -d "" -ra gpus <<< "$gpu_cmd"

            # Remove duplicate Intel Graphics outputs.
            # This fixes cases where the outputs are both
            # Intel but not entirely identical.
            #
            # Checking the first two array elements should
            # be safe since there won't be 2 intel outputs if
            # there's a dedicated GPU in play.
            [[ "${gpus[0]}" == *Intel* && "${gpus[1]}" == *Intel* ]] && unset -v "gpus[0]"

            for gpu in "${gpus[@]}"; do
                # GPU shorthand tests.
                [[ "$gpu_type" == "dedicated" && "$gpu" == *Intel* ]] || \
                [[ "$gpu_type" == "integrated" && ! "$gpu" == *Intel* ]] && \
                    { unset -v gpu; continue; }

                case $gpu in
                    *"Advanced"*)
                        brand="${gpu/*AMD*ATI*/AMD ATI}"
                        brand="${brand:-${gpu/*AMD*/AMD}}"
                        brand="${brand:-${gpu/*ATI*/ATi}}"

                        gpu="${gpu/\[AMD\/ATI\] }"
                        gpu="${gpu/\[AMD\] }"
                        gpu="${gpu/OEM }"
                        gpu="${gpu/Advanced Micro Devices, Inc.}"
                        gpu="${gpu/*\[}"
                        gpu="${gpu/\]*}"
                        gpu="$brand $gpu"
                    ;;

                    *"NVIDIA"*)
                        gpu="${gpu/*NVIDIA}"
                        gpu="${gpu/*\[}"
                        gpu="${gpu/\]*}"
                        gpu="NVIDIA $gpu"
                    ;;

                    *"Intel"*)
                        gpu="${gpu/*Intel/Intel}"
                        gpu="${gpu/\(R\)}"
                        gpu="${gpu/Corporation}"
                        gpu="${gpu/ \(*}"
                        gpu="${gpu/Integrated Graphics Controller}"
                        gpu="${gpu/*Xeon*/Intel HD Graphics}"

                        [[ -z "$(trim "$gpu")" ]] && gpu="Intel Integrated Graphics"
                    ;;

                    *"MCST"*)
                        gpu="${gpu/*MCST*MGA2*/MCST MGA2}"
                    ;;

                    *"VirtualBox"*)
                        gpu="VirtualBox Graphics Adapter"
                    ;;

                    *) continue ;;
                esac

                if [[ "$gpu_brand" == "off" ]]; then
                    gpu="${gpu/AMD }"
                    gpu="${gpu/NVIDIA }"
                    gpu="${gpu/Intel }"
                fi

                prin "${subtitle:+${subtitle}${gpu_name}}" "$gpu"
            done

            return
        ;;

        "Mac OS X"|"macOS")
            if [[ -f "${cache_dir}/neofetch/gpu" ]]; then
                source "${cache_dir}/neofetch/gpu"

            else
                if [[ $(uname -m) == 'arm64' ]]; then
                    chipset=$(system_profiler SPDisplaysDataType | awk '/Chipset Model/ { printf "%s %s %s", $3, $4, $5 }')
                    cores=$(system_profiler SPDisplaysDataType | awk '/Total Number of Cores/ { printf "%d", $5 }')
                    gpu="${chipset} (${cores})"
                else
                    gpu="$(system_profiler SPDisplaysDataType |\
                        awk -F': ' '/^\ *Chipset Model:/ {printf $2 ", "}')"
                    gpu="${gpu//\/ \$}"
                    gpu="${gpu%,*}"
                fi

                cache "gpu" "$gpu"
            fi
        ;;

        "iPhone OS")
            case $kernel_machine in
                "iPhone1,"[1-2]):                             "PowerVR MBX Lite 3D" ;;
                "iPhone2,1" | "iPhone3,"[1-3] | "iPod3,1" | "iPod4,1" | "iPad1,"[1-2]):
                    "PowerVR SGX535"
                ;;
                "iPhone4,1" | "iPad2,"[1-7] | "iPod5,1"):     "PowerVR SGX543MP2" ;;
                "iPhone5,"[1-4]):                             "PowerVR SGX543MP3" ;;
                "iPhone6,"[1-2] | "iPad4,"[1-9]):             "PowerVR G6430" ;;
                "iPhone7,"[1-2] | "iPod7,1" | "iPad5,"[1-2]): "PowerVR GX6450" ;;
                "iPhone8,"[1-4] | "iPad6,1"[12]):             "PowerVR GT7600" ;;
                "iPhone9,"[1-4] | "iPad7,"[5-6]):             "PowerVR GT7600 Plus" ;;
                "iPhone10,"[1-6]):                            "Apple Designed GPU (A11)" ;;
                "iPhone11,"[2468] | "iPad11,"[123467]):       "Apple Designed GPU (A12)" ;;
                "iPhone12,"[1358] | "iPad12,"[12]):           "Apple Designed GPU (A13)" ;;
                "iPhone13,"[1234] | "iPad13,"[12]):           "Apple Designed GPU (A14)" ;;

                "iPad3,"[1-3]):     "PowerVR SGX534MP4" ;;
                "iPad3,"[4-6]):     "PowerVR SGX554MP4" ;;
                "iPad5,"[3-4]):     "PowerVR GXA6850" ;;
                "iPad6,"[3-8]):     "PowerVR 7XT" ;;
                "iPad8,"[1-8]):     "Apple Designed GPU (A12X)" ;;
                "iPad8,9" | "iPad8,1"[0-2]):        "Apple Designed GPU (A12Z)" ;;
                "iPad13,"[4-9] | "iPad13,1"[0-1]):  "Apple Designed GPU (M1)" ;;
                "iPad14,"[1-2]):    "Apple Designed GPU (A15)" ;;
                "iPad14,"[3-6]):    "Apple Designed GPU (M2)" ;;

                "iPod1,1" | "iPod2,1")
                    : "PowerVR MBX Lite"
                ;;
            esac
            gpu="$_"
        ;;

        "Windows")
            wmic path Win32_VideoController get caption | while read -r line; do
                line=$(trim "$line")

                case $line in
                    *Caption*|'')
                        continue
                    ;;

                    *)
                        prin "${subtitle:+${subtitle}${gpu_name}}" "$line"
                    ;;
                esac
            done
        ;;

        "Interix")
            /dev/fs/C/Windows/System32/wbem/WMIC.exe path Win32_VideoController get caption | while read -r line; do
                line=$(trim "$line")

                case $line in
                    *Caption*|'')
                        continue
                    ;;

                    *)
                        prin "${subtitle:+${subtitle}${gpu_name}}" "$line"
                    ;;
                esac
            done
        ;;

        "Haiku")
            gpu="$(listdev | grep -A2 -F 'device Display controller' |\
                   awk -F':' '/device [^D]/ {print $2}')"
        ;;

        *)
            case $kernel_name in
                "FreeBSD"* | "DragonFly"*)
                    gpu="$(pciconf -lv | grep -B 4 -F "VGA" | grep -F "device")"
                    gpu="${gpu/*device*= }"
                    gpu="$(trim_quotes "$gpu")"
                ;;

                *)
                    gpu="$(glxinfo -B | grep -F 'OpenGL renderer string')"
                    gpu="${gpu/OpenGL renderer string: }"
                ;;
            esac
        ;;
    esac

    if [[ "$gpu_brand" == "off" ]]; then
        gpu="${gpu/AMD}"
        gpu="${gpu/NVIDIA}"
        gpu="${gpu/Intel}"
    fi
}

get_memory() {
    case $os in
        "Linux" | "Windows")
            # MemUsed = Memtotal + Shmem - MemFree - Buffers - Cached - SReclaimable
            # Source: https://github.com/KittyKatt/screenFetch/issues/386#issuecomment-249312716
            while IFS=":" read -r a b; do
                case $a in
                    "MemTotal") ((mem_used+=${b/kB})); mem_total="${b/kB}" ;;
                    "Shmem") ((mem_used+=${b/kB}))  ;;
                    "MemFree" | "Buffers" | "Cached" | "SReclaimable")
                        mem_used="$((mem_used-${b/kB}))"
                    ;;

                    # Available since Linux 3.14rc (34e431b0ae398fc54ea69ff85ec700722c9da773).
                    # If detected this will be used over the above calculation for mem_used.
                    "MemAvailable")
                        mem_avail=${b/kB}
                    ;;
                esac
            done < /proc/meminfo

            [[ $mem_avail ]] && mem_used=$((mem_total - mem_avail))
        ;;

        "Mac OS X" | "macOS" | "iPhone OS")
            hw_pagesize="$(sysctl -n hw.pagesize)"
            mem_total="$(($(sysctl -n hw.memsize) / 1024))"
            pages_app="$(($(sysctl -n vm.page_pageable_internal_count) - $(sysctl -n vm.page_purgeable_count)))"
            pages_wired="$(vm_stat | awk '/ wired/ { print $4 }')"
            pages_compressed="$(vm_stat | awk '/ occupied/ { printf $5 }')"
            pages_compressed="${pages_compressed:-0}"
            mem_used="$(((pages_app + ${pages_wired//.} + ${pages_compressed//.}) * hw_pagesize / 1024))"
        ;;

        "BSD" | "MINIX" | "ravynOS")
            # Mem total.
            case $kernel_name in
                "NetBSD"*) mem_total="$(($(sysctl -n hw.physmem64) / 1024))" ;;
                *) mem_total="$(($(sysctl -n hw.physmem) / 1024))" ;;
            esac

            # Mem free.
            case $kernel_name in
                "NetBSD"*)
                    mem_free="$(awk -F ':|kB' '/MemFree:/ {printf $2}' /proc/meminfo)"
                ;;

                "FreeBSD"* | "DragonFly"*)
                    hw_pagesize="$(sysctl -n hw.pagesize)"
                    mem_inactive="$(($(sysctl -n vm.stats.vm.v_inactive_count) * hw_pagesize))"
                    mem_unused="$(($(sysctl -n vm.stats.vm.v_free_count) * hw_pagesize))"
                    mem_cache="$(($(sysctl -n vm.stats.vm.v_cache_count) * hw_pagesize))"
                    mem_free="$(((mem_inactive + mem_unused + mem_cache) / 1024))"
                ;;

                "MINIX")
                    mem_free="$(top -d 1 | awk -F ',' '/^Memory:/ {print $2}')"
                    mem_free=$(("${mem_free/M Free}" * 1024))
                ;;

                "OpenBSD"*) ;;
                *) mem_free="$(vmstat | awk 'END {printf $5}')" ;;
            esac

            # Mem used.
            case $kernel_name in
                "OpenBSD"*)
                    mem_used="$(vmstat | awk 'END {printf $3}')"
                    mem_used=$(("${mem_used/M}" * 1024))
                ;;

                *) mem_used="$((mem_total - mem_free))" ;;
            esac
        ;;

        "Solaris" | "illumos" | "AIX")
            hw_pagesize="$(pagesize)"
            case $os in
                "Solaris" | "illumos")
                    pages_total="$(kstat -p unix:0:system_pages:pagestotal | awk '{print $2}')"
                    pages_free="$(kstat -p unix:0:system_pages:pagesfree | awk '{print $2}')"
                ;;

                "AIX")
                    IFS=$'\n'"| " read -d "" -ra mem_stat <<< "$(svmon -G -O unit=page)"
                    pages_total="${mem_stat[11]}"
                    pages_free="${mem_stat[16]}"
                ;;
            esac
            mem_total="$((pages_total * hw_pagesize / 1024))"
            mem_free="$((pages_free * hw_pagesize / 1024))"
            mem_used="$((mem_total - mem_free))"
        ;;

        "Haiku")
            mem_total="$(($(sysinfo -mem | awk -F '\\/ |)' '{print $2; exit}') / 1024))"
            mem_used="$(sysinfo -mem | awk -F '\\/|)' '{print $2; exit}')"
            mem_used="$((${mem_used/max} / 1024))"
        ;;

        "IRIX")
            IFS=$'\n' read -d "" -ra mem_cmd <<< "$(pmem)"
            IFS=" " read -ra mem_stat <<< "${mem_cmd[0]}"

            mem_total="${mem_stat[3]}"
            mem_free="${mem_stat[5]}"
            mem_used="$((mem_total - mem_free))"
        ;;

        "FreeMiNT")
            mem="$(awk -F ':|kB' '/MemTotal:|MemFree:/ {printf $2, " "}' /kern/meminfo)"
            mem_free="${mem/*  }"
            mem_total="${mem/$mem_free}"
            mem_used="$((mem_total - mem_free))"
        ;;

        "Interix")
            mem_total="$(/dev/fs/C/Windows/System32/wbem/WMIC.exe computersystem get TotalPhysicalMemory)"
            mem_total="${mem_total//[[:space:]]}"
            mem_total="${mem_total/TotalPhysicalMemory}"
            mem_total="$((mem_total / 1024 / 1024))"

            mem_free="$(/dev/fs/C/Windows/System32/wbem/WMIC.exe os get FreePhysicalMemory)"
            mem_free="${mem_free//[[:space:]]}"
            mem_free="${mem_free/FreePhysicalMemory}"
            mem_free="$((mem_free / 1024))"

            mem_used="$((mem_total - mem_free))"
        ;;

        "Ironclad")
            mem_free="$(( $(showmem -f) * 1000 ))"
            mem_used="$(( $(showmem -u) * 1000 ))"
            mem_total="$(( $(showmem -t) * 1000 ))"
    esac

    [[ "$memory_percent" == "on" ]] && ((mem_perc=mem_used * 100 / mem_total))

    # Creates temp variables: mem_unit_divider, mem_unit_multiplier
    mem_unit_divider=1
    mem_unit_multiplier=$((10 ** mem_precision))

    # Keep a copy of the original kibibyte values because progress bar needs them
    mu_kib="$mem_used"
    mt_kib="$mem_total"

    case $memory_unit in
        tib)
            mem_label=TiB
            mem_unit_divider=$((1024 * 1024 * 1024))
        ;;

        gib)
            mem_label=GiB
            mem_unit_divider=$((1024 * 1024))
        ;;

        kib)
        ;;

        *)
            mem_label=MiB
            mem_unit_divider=1024
        ;;
    esac

    # Uses temp variables from above: mem_unit_divider, mem_unit_multiplier
    if test "$mem_unit_divider" -ge 1; then
        case ${mem_precision} in
            0)
                mem_used="$((mem_used / mem_unit_divider))"
                mem_total="$((mem_total / mem_unit_divider))"
            ;;

            *)
                mem_used="$((mem_used / mem_unit_divider)).$(printf "%0*d" "${mem_precision}" \
                    $((mem_used % mem_unit_divider * mem_unit_multiplier / mem_unit_divider)))"
                mem_total="$((mem_total / mem_unit_divider)).$(printf "%0*d" "${mem_precision}" \
                    $((mem_total % mem_unit_divider * mem_unit_multiplier / mem_unit_divider)))"
            ;;
        esac
    fi

    memory="${mem_used} ${mem_label:-KiB} / ${mem_total} ${mem_label:-KiB} ${mem_perc:+(${mem_perc}%)}"

    # Bars.
    case $memory_display in
        "bar")     memory="$(bar "${mu_kib}" "${mt_kib}")" ;;
        "infobar") memory="${memory} $(bar "${mu_kib}" "${mt_kib}")" ;;
        "barinfo") memory="$(bar "${mu_kib}" "${mt_kib}")${info_color} ${memory}" ;;
    esac
}

get_network() {
    case $os in
        "Linux")
            while IFS= read -r i; do
                # List all operational, physical devices
                if [ "$(cat "$i/operstate")" = "up" ] && [ -e "$i/device" ]; then
                    if [ ! -e "$i/phy80211" ]; then
                        networks+="$(cat "$i/speed")"
                    else
                        networks+="Wifi"
                        phy="$(cat "$i/phy80211/name")"
                        (iw "$phy" info | grep -qF 'VHT Capabilities') && networks+='6'
                    fi
                    networks+=$'\n'
                fi
            done < <(find /sys/class/net/ -type l)
        ;;
        "Mac OS X"|"macOS")
            ActiveNetwork=$(route get default | grep interface | awk '{print $2}')
            ActiveNetworkName=$(networksetup -listallhardwareports | grep -B 1 "$ActiveNetwork" | awk '/Hardware Port/{print}'| awk '{print $3}')
            if [[ $ActiveNetworkName == "Wi-Fi" ]]; then
                LinkSpeed="$(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | awk '/maxRate/{print}' | awk '{print $2}' )Mbps"
            else
                LinkSpeed="$(ifconfig "$ActiveNetwork" | awk '/media/{print}' | sed -E "s/.*\((.*)\).*/\1/")"
            fi
            network="$ActiveNetwork: $ActiveNetworkName@$LinkSpeed"
        ;;
    esac
    while IFS=' ' read -r n i; do
        if [ -n "$i" ]; then
            [ "$n" -gt 1 ] && network+="${n}x "
            if [ "$i" = "Wifi" ]; then
                network+="Wifi; "
            elif [ "$i" = "Wifi6" ]; then
                network+="Wifi6; "
            elif [ "$i" = "-1" ]; then
                network+="Unknown; "
            elif [ "${i%000}" = "$i" ]; then
                network+="$i Mbps; "
            elif [ "$i" = "2500" ]; then
                network+="2.5 Gbps; "
            else
                network+="${i%000} Gbps; "
            fi
        fi
    done < <(sort -rn <<<"$networks" | uniq -c)
    if [ -n "$network" ]; then
        network="${network%; }"
    fi
}

get_bluetooth() {
    # Find bluetooth using lsusb
    if command -v lsusb &> /dev/null; then
        bluetooth="$(lsusb | cut -c34- | grep -i bluetooth)"
    fi

    # Remove "Bluetooth" suffix
    bluetooth="${bluetooth%[Bb]luetooth}"
}

get_song() {
    players=(
        "amarok"
        "audacious"
        "banshee"
        "bluemindo"
        "cider"
        "clementine"
        "cmus"
        "deadbeef"
        "deepin-music"
        "dragon"
        "elisa"
        "exaile"
        "gnome-music"
        "gmusicbrowser"
        "gogglesmm"
        "guayadeque"
        "io.elementary.music"
        "iTunes"
        "Music"
        "juk"
        "lollypop"
        "MellowPlayer"
        "mocp"
        "mopidy"
        "mpd"
        "muine"
        "netease-cloud-music"
        "olivia"
        "plasma-browser-integration"
        "playerctl"
        "pogo"
        "pragha"
        "qmmp"
        "quodlibet"
        "rhythmbox"
        "sayonara"
        "smplayer"
        "spotify"
        "Spotify"
        "strawberry"
        "tauonmb"
        "tomahawk"
        "tidal-hifi"
        "vlc"
        "xmms2d"
        "xnoise"
        "yarock"
    )

    printf -v players "|%s" "${players[@]}"
    player="$(ps aux | awk -v pattern="(${players:1})" \
        '!/ awk / && !/iTunesHelper/ && match($0,pattern){print substr($0,RSTART,RLENGTH); exit}')"

    [[ "$music_player" && "$music_player" != "auto" ]] && player="$music_player"

    get_song_dbus() {
        # Multiple players use an almost identical dbus command to get the information.
        # This function saves us using the same command throughout the function.
        song="$(\
            dbus-send --print-reply --dest=org.mpris.MediaPlayer2."${1}" /org/mpris/MediaPlayer2 \
            org.freedesktop.DBus.Properties.Get string:'org.mpris.MediaPlayer2.Player' \
            string:'Metadata' |\
            awk -F '"' 'BEGIN {RS=" entry"}; /"xesam:artist"/ {a = $4} /"xesam:album"/ {b = $4}
                        /"xesam:title"/ {t = $4} END {print a " \n" b " \n" t}'
        )"
    }

    case ${player/*\/} in
        "mocp"*)          song="$(mocp -Q '%artist \n%album \n%song')" ;;
        "deadbeef"*)      song="$(deadbeef --nowplaying-tf '%artist% \\n%album% \\n%title%')" ;;
        "qmmp"*)          song="$(qmmp --nowplaying '%p \n%a \n%t')" ;;
        "gnome-music"*)   get_song_dbus "GnomeMusic" ;;
        "lollypop"*)      get_song_dbus "Lollypop" ;;
        "clementine"*)    get_song_dbus "clementine" ;;

        "juk"*)           get_song_dbus "juk" ;;
        "bluemindo"*)     get_song_dbus "Bluemindo" ;;
        "guayadeque"*)    get_song_dbus "guayadeque" ;;
        "yarock"*)        get_song_dbus "yarock" ;;
        "deepin-music"*)  get_song_dbus "DeepinMusic" ;;
        "tomahawk"*)      get_song_dbus "tomahawk" ;;
        "elisa"*)         get_song_dbus "elisa" ;;
        "sayonara"*)      get_song_dbus "sayonara" ;;
        "audacious"*)     get_song_dbus "audacious" ;;
        "vlc"*)           get_song_dbus "vlc" ;;
        "gmusicbrowser"*) get_song_dbus "gmusicbrowser" ;;
        "pragha"*)        get_song_dbus "pragha" ;;
        "amarok"*)        get_song_dbus "amarok" ;;
        "dragon"*)        get_song_dbus "dragonplayer" ;;
        "smplayer"*)      get_song_dbus "smplayer" ;;
        "rhythmbox"*)     get_song_dbus "rhythmbox" ;;
        "strawberry"*)    get_song_dbus "strawberry" ;;
        "gogglesmm"*)     get_song_dbus "gogglesmm" ;;
        "xnoise"*)        get_song_dbus "xnoise" ;;
        "tauonmb"*)       get_song_dbus "tauon" ;;
        "tidal-hifi"*)    get_song_dbus "tidal-hifi" ;;
        "olivia"*)        get_song_dbus "olivia" ;;
        "exaile"*)        get_song_dbus "exaile" ;;
        "cider"*)         get_song_dbus "cider2" ;;
        "netease-cloud-music"*)        get_song_dbus "netease-cloud-music" ;;
        "plasma-browser-integration"*) get_song_dbus "plasma-browser-integration" ;;
        "io.elementary.music"*)        get_song_dbus "Music" ;;
        "MellowPlayer"*)  get_song_dbus "MellowPlayer3" ;;

        "mpd"* | "mopidy"*)
            song="$(mpc -f '%artist% \n%album% \n%title%' current "${mpc_args[@]}")"
        ;;

        "xmms2d"*)
            song="$(xmms2 current -f "\${artist}"$' \n'"\${album}"$' \n'"\${title}")"
        ;;

        "cmus"*)
            # NOTE: cmus >= 2.8.0 supports mpris2
            song="$(cmus-remote -Q | awk '/tag artist/ {$1=$2=""; a=$0}
                                          /tag album / {$1=$2=""; b=$0}
                                          /tag title/  {$1=$2=""; t=$0}
                                          END {print a " \n" b " \n" t}')"
        ;;

        "spotify"*)
            case $os in
                "Linux") get_song_dbus "spotify" ;;

                "Mac OS X"|"macOS")
                    song="$(osascript -e 'tell application "Spotify" to artist of current track as¬
                                          string & "\n" & album of current track as¬
                                          string & "\n" & name of current track as string')"
                ;;
            esac
        ;;

        "itunes"*)
            song="$(osascript -e 'tell application "iTunes" to artist of current track as¬
                                  string & "\n" & album of current track as¬
                                  string & "\n" & name of current track as string')"
        ;;

        "music"*)
            song="$(osascript -e 'tell application "Music" to artist of current track as¬
                                  string & "\n" & album of current track as¬
                                  string & "\n" & name of current track as string')"
        ;;

        "banshee"*)
            song="$(banshee --query-artist --query-album --query-title |\
                    awk -F':' '/^artist/ {a=$2} /^album/ {b=$2} /^title/ {t=$2}
                               END {print a " \n" b " \n"t}')"
        ;;

        "muine"*)
            song="$(dbus-send --print-reply --dest=org.gnome.Muine /org/gnome/Muine/Player \
                    org.gnome.Muine.Player.GetCurrentSong |
                    awk -F':' '/^artist/ {a=$2} /^album/ {b=$2} /^title/ {t=$2}
                               END {print a " \n" b " \n" t}')"
        ;;

        "quodlibet"*)
            song="$(dbus-send --print-reply --dest=net.sacredchao.QuodLibet \
                    /net/sacredchao/QuodLibet net.sacredchao.QuodLibet.CurrentSong |\
                    awk -F'"' 'BEGIN {RS=" entry"}; /"artist"/ {a=$4} /"album"/ {b=$4}
                    /"title"/ {t=$4} END {print a " \n" b " \n" t}')"
        ;;

        "pogo"*)
            song="$(dbus-send --print-reply --dest=org.mpris.pogo /Player \
                    org.freedesktop.MediaPlayer.GetMetadata |
                    awk -F'"' 'BEGIN {RS=" entry"}; /"artist"/ {a=$4} /"album"/ {b=$4}
                    /"title"/ {t=$4} END {print a " \n" b " \n" t}')"
        ;;

        "playerctl"*)
            song="$(playerctl metadata --format '{{ artist }} \n{{ album }} \n{{ title }}')"
         ;;

        *) mpc &>/dev/null && song="$(mpc -f '%artist% \n%album% \n%title%' current)" || return ;;
    esac

    IFS=$'\n' read -d "" -r artist album title <<< "${song//'\n'/$'\n'}"

    # Make sure empty tags are truly empty.
    artist="$(trim "$artist")"
    album="$(trim "$album")"
    title="$(trim "$title")"

    # Set default values if no tags were found.
    : "${artist:=Unknown Artist}" "${album:=Unknown Album}" "${title:=Unknown Song}"

    # Display Artist, Album and Title on separate lines.
    if [[ "$song_shorthand" == "on" ]]; then
        prin "Artist" "$artist"
        prin "Album"  "$album"
        prin "Song"   "$title"
    else
        song="${song_format/\%artist\%/$artist}"
        song="${song/\%album\%/$album}"
        song="${song/\%title\%/$title}"
    fi
}

get_resolution() {
    case $os in
        "Mac OS X"|"macOS")
            resolution=""
            temp_plist="/tmp/neofetch_system_profiler_SPDisplaysDataType.xml" # PlistBuddy doesn't support reading from /dev/stdin
            if system_profiler SPDisplaysDataType -xml > $temp_plist; then
                for ((gpu=0; gpu<999; gpu++)); do
                    if PlistBuddy -c "print 0:_items:${gpu}" $temp_plist &> /dev/null; then
                        for ((display=0; display<999; display++)); do
                            if spdisplays_resolution="$(PlistBuddy -c "print 0:_items:${gpu}:spdisplays_ndrvs:${display}:_spdisplays_resolution" $temp_plist)" 2>/dev/null; then
                                spdisplays_resolution="${spdisplays_resolution//.[0-9][0-9]/}"
                                if spdisplays_pixels="$(PlistBuddy -c "print 0:_items:${gpu}:spdisplays_ndrvs:${display}:_spdisplays_pixels" $temp_plist)" 2>/dev/null; then
                                    scaled_x="$(echo "$spdisplays_resolution" | awk '{print $1}')"
                                    output_x="$(echo "$spdisplays_pixels" | awk '{print $1}')"
                                    (( scale_factor=output_x/scaled_x ))
                                    if [[ $scale_factor -gt 1 ]]; then
                                        if [[ "$spdisplays_resolution" == *"@"* ]]; then
                                            spdisplays_resolution="${spdisplays_resolution// @/ @${scale_factor}x @}"
                                        else
                                            spdisplays_resolution="${spdisplays_resolution} @ ${scale_factor}x"
                                        fi
                                    fi
                                fi
                                spdisplays_resolution="${spdisplays_resolution// x /x}"
                                [[ $gpu -gt 0 || $display -gt 0 ]] && resolution+=", "
                                resolution+="${spdisplays_resolution}"
                            else
                                break
                            fi
                        done
                    else
                        break
                    fi
                done

                if [[ "$refresh_rate" == "off" ]]; then
                    resolution="${resolution/ @ [0-9][0-9][0.9]Hz}"
                    resolution="${resolution/ @ [0-9][0.9]Hz}"
                    resolution="${resolution/ @ [0-9]Hz}"
                else
                    resolution="${resolution// @ 0Hz}"
                fi

                rm $temp_plist
            fi
        ;;

        "iPhone OS")
            case $kernel_machine in
                "iPhone1,"[1-2] | "iPhone2,1" | "iPod"[1-3]",1"):                                                                    "320x480"   ;;
                "iPhone3,"[1-3] | "iPhone4,1" | "iPod4,1"):                                                                          "640x960"   ;;
                "iPhone5,"[1-4] | "iPhone6,"[1-2] | "iPhone8,4" | "iPod"[5-7]",1" | "iPod9,1"):                                      "640x1136"  ;;
                "iPad1,"[1-2] | "iPad2,"[1-7]):                                                                                      "768x1024"  ;;
                "iPhone10,1" | "iPhone10,4" | "iPhone9,1" | "iPhone9,3" | "iPhone8,1" | "iPhone7,2" | "iPhone12,8" | "iPhone14,6"):  "750x1334"  ;;
                "iPhone11,8" | "iPhone12,1"):                                                                                        "828x1792"  ;;
                "iPhone7,1" | "iPhone8,2" | "iPhone9,2" | "iPhone9,4" | "iPhone10,2"):                                               "1080x1920" ;;
                "iPhone13,1" | "iPhone14,4"):                                                                                        "1080x2340" ;;
                "iPhone10,3" | "iPhone10,6" | "iPhone11,2" | "iPhone12,3"):                                                          "1125x2436" ;;
                "iPhone13,"[2-3] | "iPhone14,2" | "iPhone14,5" | "iPhone14,7"):                                                      "1170x2532" ;;
                "iPhone15,2"):                                                                                                       "1179x2556" ;;
                "iPad4,"[1-9] | "iPad3,"[1-6] | "iPad6,"[3-4] | "iPad6,1"[1-2] | "iPad5,"[1-4] | "iPad7,"[5-6] | "iPad11,"[1-2]):    "1536x2048" ;;
                "iPhone11,4" | "iPhone11,6" | "iPhone12,5"):                                                                         "1242x2688" ;;
                "iPad14,"[1-2]):                                                                                                     "1488x2266" ;;
                "iPad7,1"[1-2] | "iPad11,"[6-7] | "iPad12,"[1-2]):                                                                   "1620x2160" ;;
                "iPhone13,4" | "iPhone14,3" | "iPhone14,8"):                                                                         "1284x2778" ;;
                "iPhone15,3"):                                                                                                       "1290x2796" ;;
                "iPad11,"[3-4] | "iPad7,"[3-4]):                                                                                     "1668x2224" ;;
                "iPad13,"[1-2] | "iPad13,1"[6-9]):                                                                                   "1640x2360" ;;
                "iPad8,"[1-4] | "iPad8,"[9-10] | "iPad13,"[4-7] | "iPad14,"[3-6]):                                                   "1668x2388" ;;
                "iPad6,"[7-8] | "iPad7,"[1-2] | "iPad8,"[5-8] | "iPad8,1"[1-2] | "iPad13,"[8-9] | "iPad13,1"[0-1] | "iPad14,"[5-6]): "2048x2732" ;;
            esac
            resolution="$_"
        ;;

        "Windows")
            IFS=$'\n' read -d "" -ra sw \
                <<< "$(wmic path Win32_VideoController get CurrentHorizontalResolution)"

            IFS=$'\n' read -d "" -ra sh \
                <<< "$(wmic path Win32_VideoController get CurrentVerticalResolution)"

            sw=("${sw[@]//CurrentHorizontalResolution}")
            sh=("${sh[@]//CurrentVerticalResolution}")

            for ((mn = 0; mn < ${#sw[@]}; mn++)) {
                [[ ${sw[mn]//[[:space:]]} && ${sh[mn]//[[:space:]]} ]] &&
                    resolution+="${sw[mn]//[[:space:]]}x${sh[mn]//[[:space:]]}, "
            }

            resolution=${resolution%,}
        ;;

        "Haiku")
            resolution="$(screenmode | awk -F ' |, ' 'END{printf $2 "x" $3 " @ " $6 $7}')"

            [[ "$refresh_rate" == "off" ]] && resolution="${resolution/ @*}"
        ;;

        "FreeMiNT")
            # Need to block X11 queries
        ;;

        *)
            if type -p xrandr >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
                case $refresh_rate in
                    "on")
                        resolution="$(xrandr --nograb --current |\
                                      awk 'match($0,/[0-9]*\.[0-9]*\*/) {
                                           printf $1 " @ " substr($0,RSTART,RLENGTH) "Hz, "}')"
                    ;;

                    "off")
                        resolution="$(xrandr --nograb --current |\
                                      awk -F 'connected |\\+|\\(' \
                                             '/ connected.*[0-9]+x[0-9]+\+/ && $2 {printf $2 ", "}')"

                        resolution="${resolution/primary, }"
                        resolution="${resolution/primary }"
                    ;;
                esac
                resolution="${resolution//\*}"

            elif type -p xwininfo >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
                read -r w h \
                    <<< "$(xwininfo -root | awk -F':' '/Width|Height/ {printf $2}')"
                resolution="${w}x${h}"

            elif type -p xdpyinfo >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
                resolution="$(xdpyinfo | awk '/dimensions:/ {printf $2}')"

            elif [[ -d /sys/class/drm ]]; then
                for dev in /sys/class/drm/*/modes; do
                    read -r single_resolution _ < "$dev"

                    [[ $single_resolution ]] && resolution="${single_resolution}, ${resolution}"
                done
            fi
        ;;
    esac

    resolution="${resolution%%,}"
    resolution="${resolution%%, }"
    [[ -z "${resolution/x}" ]] && resolution=
}

get_style() {
    # Fix weird output when the function is run multiple times.
    unset qt_theme gtk2_theme gtk3_theme theme path

    if [[ "$DISPLAY" && $os != "Mac OS X" && $os != "macOS" ]]; then
        # Get DE if user has disabled the function.
        ((de_run != 1)) && get_de

        # Remove version from '$de'.
        [[ $de_version == on ]] && de=${de/ *}

        # Check for DE Theme.
        case $de in
            "KDE"* | "Plasma"*)
                kde_config_dir

                if [[ -f "${kde_config_dir}/kdeglobals" ]]; then
                    kde_config_file="${kde_config_dir}/kdeglobals"
                    qt_theme="$(grep "^${kde}" "$kde_config_file")"
                    qt_theme="${qt_theme/*=}"

                    if [[ "$kde" == "widgetStyle" ]] && grep -q "\[Theme\]" "$HOME/.config/plasmarc"; then
                        kde_theme="$(awk '/name=/ {gsub(/name=/,"",$0);print $0;exit}' "$HOME/.config/plasmarc")"
                    else
                        kde_theme="$(grep "^${kde}" "$kde_config_file")"
                        kde_theme="${kde_theme/*=}"
                    fi

                    if [[ "$kde" == "font" ]]; then
                        kde_font_size="${kde_theme#*,}"
                        kde_font_size="${kde_font_size/,*}"
                        kde_theme="${kde_theme/,*} ${kde_theme/*,} ${kde_font_size}"
                    fi

                    if [[ "$kde" == "cursorTheme" ]]; then
                        if [[ -f "${kde_config_dir}/kcminputrc" ]]; then
                            kde_config_file="${kde_config_dir}/kcminputrc"
                        elif [[ -f "${kde_config_dir}/startupconfig" ]]; then
                            kde="cursortheme"
                            kde_config_file="${kde_config_dir}/startupconfig"
                        fi
                        kde_theme="$(grep "${kde}" "$kde_config_file")"
                        kde_theme="${kde_theme/*=}"
                    fi
                    #kde_theme="$kde_theme [KDE], "
                else
                    err "Theme: KDE config files not found, skipping."
                fi
            ;;

            *"Cinnamon"*)
                if type -p gsettings >/dev/null; then
                    gtk3_theme="$(gsettings get org.cinnamon.desktop.interface "$gsettings")"
                    gtk2_theme="$gtk3_theme"
                fi
            ;;

            "Gnome"* | "Unity"* | "Budgie"*)
                if type -p gsettings >/dev/null; then
                    gtk3_theme="$(gsettings get org.gnome.desktop.interface "$gsettings")"
                    gtk2_theme="$gtk3_theme"

                elif type -p gconftool-2 >/dev/null; then
                    gtk2_theme="$(gconftool-2 -g /desktop/gnome/interface/"$gconf")"
                fi
            ;;

            "Mate"*)
                gtk3_theme="$(gsettings get org.mate.interface "$gsettings")"
                gtk2_theme="$gtk3_theme"
            ;;

            "Xfce"*)
                type -p xfconf-query >/dev/null && \
                    gtk2_theme="$(xfconf-query -c xsettings -p "$xfconf")"
            ;;

            "Trinity")
                tde_config_dir

                if [[ -f "${tde_config_dir}/kdeglobals" ]]; then
                    tde_config_file="${tde_config_dir}/kdeglobals"
                    qt_theme="$(grep "^${kde}" "$tde_config_file")"
                    qt_theme="${qt_theme/*=}"

                else
                    err "Theme: TDE config files not found, skipping."
                fi
            ;;

            "LXQt"*)
                shopt -s nullglob
                if ! qt_theme=$(awk -F "=" -v r="^$lxqt" '
                    $1~r { theme=$2 }
                    END { print theme }
                ' {/etc/xdg,/etc/xdg/*,"$XDG_CONFIG_HOME"}/lxqt/lxqt.con?); then
                    err "Theme: Can't read LXQt config files. Unsetting Qt theme."
                    unset qt_theme
                fi
                shopt -u nullglob
            ;;

            "Fly")
                fly_config_file
                if [[ $fly == "ColorScheme" ]]; then
                    fly_theme="$(
                        basename "$(
                            awk -F '=' '/^'"${fly}"'/{print $2}' "${HOME}/.fly/paletterc"
                        )"
                    )"
                    if [[ $wm_theme == "Default" && $fly_theme != *"FlyDefault"* ]]; then
                        fly_theme=$(awk -F '=' '/^'"${fly}"'/{print $2}'\
                                        "${HOME}/.config/fly-admin-themerc")
                    fi
                elif [[ $fly == "IconTheme" ]]; then
                     fly_theme=$(awk -F '=' '/^'"${fly}"'/{print $2}' "${fly_config_file}")
                elif [[ $fly == "DefaultFont" ]]; then
                    fly_theme=$(awk -F'=' '/^'"${fly}"'/\
                                    {gsub(/"/, "", $2); \
                                    sub(/-.*/, "", $2); \
                                    print $2}' "${fly_config_file}")
                fi
                fly_theme+=" [$de], "
            ;;
        esac

        # Check for general GTK2 Theme.
        if [[ -z "$gtk2_theme" ]]; then
            if [[ -n "$GTK2_RC_FILES" ]]; then
                IFS=: read -ra rc_files <<< "$GTK2_RC_FILES"
                gtk2_theme="$(grep "^[^#]*${name}" "${rc_files[@]}")"
            elif [[ -f "${HOME}/.gtkrc-2.0"  ]]; then
                gtk2_theme="$(grep "^[^#]*${name}" "${HOME}/.gtkrc-2.0")"

            elif [[ -f "/etc/gtk-2.0/gtkrc" ]]; then
                gtk2_theme="$(grep "^[^#]*${name}" /etc/gtk-2.0/gtkrc)"

            elif [[ -f "/usr/share/gtk-2.0/gtkrc" ]]; then
                gtk2_theme="$(grep "^[^#]*${name}" /usr/share/gtk-2.0/gtkrc)"

            fi

            gtk2_theme="${gtk2_theme/*${name}*=}"
        fi

        # Check for general GTK3 Theme.
        if [[ -z "$gtk3_theme" ]] && type -p dump_xsettings >/dev/null; then
            gtk3_theme="$(dump_xsettings | sed -n "s,^${xfconf#/} ,,p")"
        fi
        if [[ -z "$gtk3_theme" ]]; then
            if [[ -f "${XDG_CONFIG_HOME}/gtk-3.0/settings.ini" ]]; then
                gtk3_theme="$(grep "^[^#]*$name" "${XDG_CONFIG_HOME}/gtk-3.0/settings.ini")"

            elif type -p gsettings >/dev/null; then
                gtk3_theme="$(gsettings get org.gnome.desktop.interface "$gsettings")"

            elif [[ -f "/etc/gtk-3.0/settings.ini" ]]; then
                gtk3_theme="$(grep "^[^#]*$name" /etc/gtk-3.0/settings.ini)"

            elif [[ -f "/usr/share/gtk-3.0/settings.ini" ]]; then
                gtk3_theme="$(grep "^[^#]*$name" /usr/share/gtk-3.0/settings.ini)"
            fi

            gtk3_theme="${gtk3_theme/${name}*=}"
        fi

        # Handle Qt5ct platform theme
        if [[ "$QT_QPA_PLATFORMTHEME" == 'qt5ct' && -f "${XDG_CONFIG_HOME}/qt5ct/qt5ct.conf" ]]; then
            qt_theme="$(grep "^${qt5ct}" "${XDG_CONFIG_HOME}/qt5ct/qt5ct.conf")"
            qt_theme="${qt_theme/*=}"
            # Reformat font, since qt5ct stores fonts in binary format
            if [[ "$qt5ct" == "general" ]]; then
                # Trim quotes and parentheses
                qt_theme="${qt_theme#'"'}"
                qt_theme="${qt_theme%'"'}"
                qt_theme="${qt_theme#@Variant(}"
                qt_theme="${qt_theme%)}"

                # Read font name
                qt5ct_font_name="${qt_theme#*@}"
                qt5ct_font_name="${qt5ct_font_name%%@*}"
                # Interpret backslashes
                qt5ct_font_name="$(printf "%b" "$qt5ct_font_name")"
                qt5ct_font_name="${qt5ct_font_name//[[:cntrl:]]}" # trim control characters

                # Get font size
                # Tread carefully, Qt sometimes uses @ in binary data
                local pre_size="${qt_theme#*@}"
                local pre_size="${pre_size#*@}"
                # Need to declare array and manually handle the second byte
                # (workaround for `od` without --endian)
                IFS=' ' local raw_size=( "$(printf "%b" "${pre_size}" | od -An -tu1 -N2)" )
                # Split the upper 4 bits (exponent) the lower 12.
                local lowers=$(( ((raw_size[0]%16)<<8) + (raw_size[1]) ))
                local upper4=$((raw_size[0]>>4 ))
                qt5ct_font_size=$(( (2**(upper4+1)) + (lowers>>(11-upper4)) ))

                qt_theme="$qt5ct_font_name, $qt5ct_font_size"
            fi
        fi

        # Forced Qt theme through environment variables - Apply only if handling widget style!
        [[ "$kde" == "widgetStyle" && "$qt_theme" ]] && qt_theme="${QT_STYLE_OVERRIDE:-"$qt_theme"}"

        # Reformat Qt fonts
        if [[ "$kde" == "font" && "$qt_theme" ]]; then
            qt_font_size="${qt_theme#*,}"
            qt_font_size="${qt_font_size/,*}"
            qt_theme="${qt_theme/,*}, ${qt_font_size}"
        fi

        # Trim whitespace.
        gtk2_theme="$(trim "$gtk2_theme")"
        gtk3_theme="$(trim "$gtk3_theme")"
        qt_theme="$(trim "$qt_theme")"
        kde_theme="$(trim "$kde_theme")"

        # Remove quotes.
        gtk2_theme="$(trim_quotes "$gtk2_theme")"
        gtk3_theme="$(trim_quotes "$gtk3_theme")"
        qt_theme="$(trim_quotes "$qt_theme")"
        kde_theme="$(trim_quotes "$kde_theme")"

        # Handle Qt theme engines that load external themes
        case "$qt_theme" in
            'Kvantum')
                if kvantum_theme="$(grep '^theme' "${XDG_CONFIG_HOME}/Kvantum/kvantum.kvconfig")"; then
                    qt_theme="$kvantum_theme"
                    qt_theme="${qt_theme/*=}"
                fi
                ;;
            *'gtk2')
                qt_theme="$gtk2_theme"
                ;;
        esac

        # Toggle visibility of GTK themes.
        [[ "$gtk2" == "off" ]] && unset gtk2_theme
        [[ "$gtk3" == "off" ]] && unset gtk3_theme
        [[ "$qt"  ==  "off" ]] && unset qt_theme
        # TODO: kde theme visibility

        # Format the string based on which themes exist.
        # append_theme theme toolkit
        append_theme() {
            if [[ "$1" ]]; then
                if [[ "$1" == "$cur_theme" ]]; then
                    theme+="/$2"
                else
                    theme+="], $1 [$2"
                    cur_theme="$1"
                fi
            fi
        }
        theme=''
        local cur_theme=''
        append_theme "$kde_theme" 'KDE'
        append_theme "$fly_theme" 'Fly'
        append_theme "$qt_theme" 'Qt'
        append_theme "$gtk2_theme" 'GTK2'
        append_theme "$gtk3_theme" 'GTK3'

        # Final string.
        if [[ -n "$theme" ]]; then
          theme+=']'
          theme="${theme#'], '}"
          theme="${theme/'GTK2/GTK3'/'GTK2/3'}"
          theme="${theme%, }"
        fi

        # Make the output shorter by removing "[GTKX]" from the string.
        if [[ "$gtk_shorthand" == "on" ]]; then
            theme="${theme// '['*']'}"
        fi
    fi
}

get_theme() {
    name="gtk-theme-name"
    gsettings="gtk-theme"
    gconf="gtk_theme"
    xfconf="/Net/ThemeName"
    kde="widgetStyle"
    lxqt="style"
    qt5ct="style=" # There is a property called 'stylesheets'.
    fly="ColorScheme"

    get_style
}

get_icons() {
    name="gtk-icon-theme-name"
    gsettings="icon-theme"
    gconf="icon_theme"
    xfconf="/Net/IconThemeName"
    kde="Theme"
    lxqt="icon_theme"
    qt5ct="icon_theme"
    fly="IconTheme"

    get_style
    icons="$theme"
}

get_font() {
    name="gtk-font-name"
    gsettings="font-name"
    gconf="font_theme"
    xfconf="/Gtk/FontName"
    kde="font"
    lxqt="font"
    qt5ct="general"
    fly="DefaultFont"

    get_style
    font="$theme"
}

get_cursor() {
    name="gtk-cursor-theme-name"
    gsettings="cursor-theme"
    gconf="cursor_theme"
    xfconf="/Gtk/CursorThemeName"
    kde="cursorTheme"

    get_style
    cursor="$theme"
}

get_java_ver() {
    if command -v java &> /dev/null; then
        java_ver=$(java -version 2>&1)
        java_ver=${java_ver%\"*}
        java_ver=${java_ver#*\"}
    fi
}

get_python_ver() {
    if command -v python &> /dev/null; then
        python_ver=$(python -VVV)
        python_ver=${python_ver//$'\n'/}
        python_ver=${python_ver//\(+([^\)])\)}
        python_ver=$(echo "$python_ver" | awk '$1=$1')
    fi
}

get_node_ver() {
    if command -v node &> /dev/null; then
        node_ver=$(node --version)
        node_ver=${node_ver#v}
    fi
}

get_term() {
    # If function was run, stop here.
    ((term_run == 1)) && return

    # Workaround for macOS systems that
    # don't support the block below.
    case $TERM_PROGRAM in
        "iTerm.app")                     term="iTerm2"                ;;
        "Terminal.app"|"Apple_Terminal") term="Apple Terminal"        ;;
        "Hyper")                         term="HyperTerm"             ;;
        *)                               term="${TERM_PROGRAM/\.app}" ;;
    esac

    # Most likely TosWin2 on FreeMiNT - quick check
    [[ "$TERM" == "tw52" || "$TERM" == "tw100" ]] && term="TosWin2"
    [[ "$SSH_CONNECTION" ]] && term="$SSH_TTY"
    [[ "$WT_SESSION" ]]     && term="Windows Terminal"

    # Check $PPID for terminal emulator.
    while [[ -z "$term" ]]; do
        parent="$(get_ppid "$parent")"
        [[ -z "$parent" ]] && break
        name="$(get_process_name "$parent")"

        case ${name##*/} in
            "${SHELL/*\/}"|*"sh"|"screen"|"su"*|"newgrp"|"hyfetch") ;;

            "login"*|*"Login"*|"init"|"(init)")
                term="$(tty)"
            ;;

            "ruby"|"1"|"tmux"*|"systemd"|"sshd"*|"python"*|\
            "USER"*"PID"*|"kdeinit"*|"launchd"*|"bwrap")
                break
            ;;

            "."*"-wrap"*)
                [[ $name =~ \.(.*)-wrap.* ]] && term=${BASH_REMATCH[1]}
            ;;

            "gnome-terminal-"*)     term="gnome-terminal" ;;
            "kgx")                  term="gnome-console" ;;
            "cutefish-terminal"*)   term="cutefish-terminal" ;;
            "urxvtd")               term="urxvt" ;;
            *"nvim")                term="Neovim Terminal" ;;
            *"NeoVimServer"*)       term="VimR Terminal" ;;

            *)
                # Fix issues with long process names on Linux.
                [[ $os == Linux ]] && term=$(realpath "/proc/$parent/exe")

                term="${name##*/}"

                # Fix wrapper names in Nix.
                [[ $term == .*-wrapped ]] && {
                   term="${term#.}"
                   term="${term%-wrapped}"
                }
            ;;
        esac
    done

    [[ $FIG_TERM == "1" ]] && term="$term + Fig"

    # Termux sets TERMUX_VERSION. Put this after the PPID check because this is
    # also set if using a terminal on an X server.
    [[ (-z "$term" && "$TERMUX_VERSION") || $term == "com.termux" ]] && term="Termux ${TERMUX_VERSION}"

    # Log that the function was run.
    term_run=1
}

get_term_font() {
    ((term_run != 1)) && get_term

    case $term in
        "alacritty"*)
            # Alacritty switched to TOML for it's config the first version
            # with that will take a long time to be in repos and gain adoption.

            shopt -s nullglob
            confs_yaml=({$XDG_CONFIG_HOME,$HOME}/{alacritty,}/{.,}alacritty.ym?)
            confs_toml=({$XDG_CONFIG_HOME,$HOME}/{alacritty,}/{.,}alacritty.tom?)
            shopt -u nullglob

            if [[ -f "${confs_toml[0]}" ]]; then
                term_font="$(awk -F' *= *' '/^\[.*\]$/{section=substr($0, 2, length-2)}
                         section == "font.normal" && $1 == "family"{sub(/^"/,"", $2);
                         sub(/"$/, "", $2); print $2}' "${confs_toml[0]}")"
            elif [[ -f "${confs_yaml[0]}" ]]; then
                term_font="$(awk '/normal:/ {while (!/family:/ || /#/)
                         {if (!getline) {exit}} print; exit}' "${confs_yaml[0]}")"
            else
                return
            fi
            term_font="${term_font/*family:}"
            term_font="${term_font/$'\n'*}"
            term_font="${term_font/\#*}"
            term_font="${term_font//\"}"
        ;;

        "Apple_Terminal"*)
            term_font="$(osascript <<END
                         tell application "Terminal" to font name of window frontmost \
                         & " " & font size of window frontmost
END
)"
        ;;

        "cutefish-terminal")
            term_font="$(awk -F '=' '/fontName=/ {a=$2} /fontPointSize=/ {b=$2} END {print a,b}' \
                         "${XDG_CONFIG_HOME}/cutefishos/cutefish-terminal.conf")"
        ;;

        "iTerm2"*)
            # Unfortunately the profile name is not unique, but it seems to be the only thing
            # that identifies an active profile. There is the "id of current session of current win-
            # dow" though, but that does not match to a guid in the plist.
            # So, be warned, collisions may occur!
            # See: https://groups.google.com/forum/#!topic/iterm2-discuss/0tO3xZ4Zlwg
            local current_profile_name profiles_count profile_name diff_font

            current_profile_name=$ITERM_PROFILE
            # Warning: Dynamic profiles are not taken into account here!
            # https://www.iterm2.com/documentation-dynamic-profiles.html
            font_file="${HOME}/Library/Preferences/com.googlecode.iterm2.plist"

            # Count Guids in "New Bookmarks"; they should be unique
            profiles_count="$(PlistBuddy -c "Print ':New Bookmarks:'" "$font_file" | \
                              grep -w -c "Guid")"

            for ((i=0; i<profiles_count; i++)); do
                profile_name="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Name:'" "$font_file")"

                if [[ "$profile_name" == "$current_profile_name" ]]; then
                    # "Normal Font"
                    term_font="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Normal Font:'" \
                                 "$font_file")"

                    # Font for non-ascii characters
                    # Only check for a different non-ascii font, if the user checked
                    # the "use a different font for non-ascii text" switch.
                    diff_font="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Use Non-ASCII Font:'" \
                                 "$font_file")"

                    if [[ "$diff_font" == "true" ]]; then
                        non_ascii="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Non Ascii Font:'" \
                                     "$font_file")"

                        [[ "$term_font" != "$non_ascii" ]] && \
                            term_font="$term_font (normal) / $non_ascii (non-ascii)"
                    fi
                fi
            done
        ;;

        "deepin-terminal"*)
            term_font="$(awk -F '=' '/font=/ {a=$2} /font_size/ {b=$2} END {print a,b}' \
                         "${XDG_CONFIG_HOME}/deepin/deepin-terminal/config.conf")"
        ;;

        "GNUstep_Terminal")
             term_font="$(awk -F '>|<' '/>TerminalFont</ {getline; f=$3}
                          />TerminalFontSize</ {getline; s=$3} END {print f,s}' \
                          "${HOME}/GNUstep/Defaults/Terminal.plist")"
        ;;

        "Hyper"*)
            term_font="$(awk -F':|,' '/fontFamily/ {print $2; exit}' "${HOME}/.hyper.js")"
            term_font="$(trim_quotes "$term_font")"
        ;;

        "kitty"*)
            term_font="from kitty.cli import *; o = create_default_opts(); \
                       print(f'{o.font_family} {o.font_size}')"
            term_font="$(kitty +runpy ''"$term_font"'')"
            term_font="${term_font//=}"
            term_font="${term_font//\'}"
        ;;

        "konsole" | "yakuake")
            # Get Process ID of current konsole window / tab
            child="$(get_ppid "$$")"

            # Loop while the process name is not "konsole"/"yakuake"
            while [[ "$(ps -p "$(get_ppid "$child")" -o comm=)" != "$term" ]]; do
                # Get the parent process ID
                child="$(get_ppid "$child")"

                # Exit the loop if the parent process ID is 1 (i.e., init)
                if [[ "$child" == "1" ]]; then
                    break
                fi
            done

            QT_BINDIR="$(qtpaths --binaries-dir)" && PATH+=":$QT_BINDIR"

            IFS=$'\n' read -d "" -ra konsole_instances \
                <<< "$(qdbus | awk '/org.kde.'"$term"'/ {print $1}')"

            for i in "${konsole_instances[@]}"; do
                IFS=$'\n' read -d "" -ra konsole_sessions <<< "$(qdbus "$i" | grep -F '/Sessions/')"

                for session in "${konsole_sessions[@]}"; do
                    if ((child == "$(qdbus "$i" "$session" processId)")); then
                        profile="$(qdbus "$i" "$session" environment |\
                                   awk -F '=' '/KONSOLE_PROFILE_NAME/ {print $2}')"
                        [[ $profile ]] || profile="$(qdbus "$i" "$session" profile)"
                        break
                    fi
                done
                [[ $profile ]] && break
            done

            [[ $profile ]] || return

            # We could have two profile files for the same profile name, take first match
            profile_filename="$(grep -l "Name=${profile}" "$HOME"/.local/share/konsole/*.profile)"
            profile_filename="${profile_filename/$'\n'*}"

            [[ $profile_filename ]] && \
                term_font="$(awk -F '=|,' '/^Font=/ {print $2,$3}' "$profile_filename")"
        ;;

        "lxterminal"*)
            term_font="$(awk -F '=' '/fontname=/ {print $2; exit}' \
                         "${XDG_CONFIG_HOME}/lxterminal/lxterminal.conf")"
        ;;

        "mate-terminal")
            # To get the actual config we have to create a temporarily file with the
            # --save-config option.
            mateterm_config="/tmp/mateterm.cfg"

            # Ensure /tmp exists and we do not overwrite anything.
            if [[ -d "/tmp" && ! -f "$mateterm_config" ]]; then
                mate-terminal --save-config="$mateterm_config"

                role="$(xprop -id "${WINDOWID}" WM_WINDOW_ROLE)"
                role="${role##* }"
                role="${role//\"}"

                profile="$(awk -F '=' -v r="$role" \
                                  '$0~r {
                                            getline;
                                            if(/Maximized/) getline;
                                            if(/Fullscreen/) getline;
                                            id=$2"]"
                                         } $0~id {if(id) {getline; print $2; exit}}' \
                           "$mateterm_config")"

                rm -f "$mateterm_config"

                mate_get() {
                   gsettings get org.mate.terminal.profile:/org/mate/terminal/profiles/"$1"/ "$2"
                }

                if [[ "$(mate_get "$profile" "use-system-font")" == "true" ]]; then
                    term_font="$(gsettings get org.mate.interface monospace-font-name)"
                else
                    term_font="$(mate_get "$profile" "font")"
                fi
                term_font="$(trim_quotes "$term_font")"
            fi
        ;;

        "mintty")
            term_font="$(awk -F '=' '!/^($|#)/ && /^\\s*Font\\s*=/ {printf $2; exit}' "${HOME}/.minttyrc")"
        ;;

        "pantheon"*)
            term_font="$(gsettings get org.pantheon.terminal.settings font)"

            [[ -z "${term_font//\'}" ]] && \
                term_font="$(gsettings get org.gnome.desktop.interface monospace-font-name)"

            term_font="$(trim_quotes "$term_font")"
        ;;

        "qterminal")
            term_font="$(awk -F '=' '/fontFamily=/ {a=$2} /fontSize=/ {b=$2} END {print a,b}' \
                         "${XDG_CONFIG_HOME}/qterminal.org/qterminal.ini")"
        ;;

        "sakura"*)
            term_font="$(awk -F '=' '/^font=/ {print $2; exit}' \
                         "${XDG_CONFIG_HOME}/sakura/sakura.conf")"
        ;;

        "st")
            term_font="$(ps -o command= -p "$parent" | grep -F -- "-f")"

            if [[ "$term_font" ]]; then
                term_font="${term_font/*-f/}"
                term_font="${term_font/ -*/}"

            else
                # On Linux we can get the exact path to the running binary through the procfs
                # (in case `st` is launched from outside of $PATH) on other systems we just
                # have to guess and assume `st` is invoked from somewhere in the users $PATH
                [[ -L "/proc/$parent/exe" ]] && binary="/proc/$parent/exe" || binary="$(type -p st)"

                # Grep the output of strings on the `st` binary for anything that looks vaguely
                # like a font definition. NOTE: There is a slight limitation in this approach.
                # Technically "Font Name" is a valid font. As it doesn't specify any font options
                # though it is hard to match it correctly amongst the rest of the noise.
                st_bin=$(strings "$binary")

                # Grab font information from strings in binary.
                term_font=${term_font:-"$(
                    grep -F -m 1 \
                        -e "pixelsize=" \
                        -e "size=" \
                        -e "antialias=" \
                        -e "autohint="  <<< "$st_bin"
                )"}

                # Grab font information from Xresources.
                [[ $st_bin == *resource* ]] && {
                    term_font=$(xrdb -query | grep -im 1 -e "^${term/d}"'\**\.*font:' -e '^\*font:' -e '^\*.font:')
                    term_font=$(trim "${term_font/*[\*.]"font:"}")
                }
            fi

            term_font="${term_font/xft:}"
            term_font="${term_font/:*}"
        ;;

        "terminology")
            term_font="$(strings "${XDG_CONFIG_HOME}/terminology/config/standard/base.cfg" |\
                         awk '/^font\.name$/{print a}{a=$0}')"
            term_font="${term_font/.pcf}"
            term_font="${term_font/:*}"
        ;;

        "termite")
            [[ -f "${XDG_CONFIG_HOME}/termite/config" ]] && \
                termite_config="${XDG_CONFIG_HOME}/termite/config"

            XDG_DIR="/etc/xdg"
            IFS=":"
            for directory in $XDG_CONFIG_DIRS; do
                if [[ -f "$directory/termite/config" ]]; then
                    XDG_DIR="$directory"
                    break
                fi
            done

            term_font="$(awk -F '= ' '/\[options\]/ {
                                          opt=1
                                      }
                                      /^\s*font/ {
                                          if(opt==1) a=$2;
                                          opt=0
                                      } END {print a}' "$XDG_DIR/termite/config" \
                         "$termite_config")"
        ;;

        "Termux $TERMUX_VERSION")
            term_font=$(fc-scan /data/data/com.termux/files/home/.termux/font.ttf|grep fullname:|cut -d '"' -f2)
            ;;

        urxvt|urxvtd|rxvt-unicode|xterm)
            xrdb=$(xrdb -query)
            term_font=$(grep -im 1 -e "^${term/d}"'\**\.*font:' -e '^\*font:' <<< "$xrdb")
            term_font=${term_font/*"*font:"}
            term_font=${term_font/*".font:"}
            term_font=${term_font/*"*.font:"}
            term_font=$(trim "$term_font")

            [[ -z $term_font && $term == xterm ]] && \
                term_font=$(grep '^XTerm.vt100.faceName' <<< "$xrdb")

            term_font=$(trim "${term_font/*"faceName:"}")

            # xft: isn't required at the beginning so we prepend it if it's missing
            [[ ${term_font:0:1} != '-' && ${term_font:0:4} != xft: ]] && \
                term_font=xft:$term_font

            # Xresources has two different font formats, this checks which
            # one is in use and formats it accordingly.
            case $term_font in
                *xft:*)
                    term_font=${term_font/xft:}
                    term_font=${term_font/:*}
                ;;

                -*)
                    IFS=- read -r _ _ term_font _ <<< "$term_font"
                ;;
            esac
        ;;

        "xfce4-terminal")
            # xfce4-terminal is in the process of convertinf config methods
            # First check the new config, then the old one
            if [[ -f "${XDG_CONFIG_HOME}/xfce4/xfconf/xfce-perchannel-xml/xfce4-terminal.xml" ]]; then
                conf="${XDG_CONFIG_HOME}/xfce4/xfconf/xfce-perchannel-xml/xfce4-terminal.xml"
                if ! grep -q 'font-use-system" type="bool" value="true' "$conf"; then
                    term_font="$(awk -F '=' '/font-name/{a=$4} END {print substr(a, 1, length(a)-2)}' "$conf")"
                else
                    term_font="true"
                fi
            else
                term_font="$(awk -F '=' '/^FontName/{a=$2}/^FontUseSystem=TRUE/{a=$0} END {print a}' \
                             "${XDG_CONFIG_HOME}/xfce4/terminal/terminalrc")"
            fi

            # This section works for either config version
            [[ "{$term_font,,}" == *"true"* ]] && \
                term_font="$(gsettings get org.gnome.desktop.interface monospace-font-name)"

            term_font="$(trim_quotes "$term_font")"

            # Default fallback font hardcoded in terminal-preferences.c
            [[ -z "$term_font" ]] && term_font="Monospace 12"
        ;;

        conemu-*)
            # Could have used `eval set -- "$ConEmuArgs"` instead for arg parsing.
            readarray -t ce_arg_list < <(xargs -n1 printf "%s\n" <<< "${ConEmuArgs-}")

            for ce_arg_idx in "${!ce_arg_list[@]}"; do
                # Search for "-LoadCfgFile" arg
                [[ "${ce_arg_list[$ce_arg_idx]}" == -LoadCfgFile ]] && {
                    # Conf path is the next arg
                    ce_conf=${ce_arg_list[++ce_arg_idx]}
                    break
                }
            done

            # https://conemu.github.io/en/ConEmuXml.html#search-sequence
            for ce_conf in "$ce_conf" "${ConEmuDir-}\ConEmu.xml" "${ConEmuDir-}\.ConEmu.xml" \
                           "${ConEmuBaseDir-}\ConEmu.xml" "${ConEmuBaseDir-}\.ConEmu.xml" \
                           "$APPDATA\ConEmu.xml" "$APPDATA\.ConEmu.xml"; do
                # Search for first conf file available
                [[ -f "$ce_conf" ]] && {
                    # Very basic XML parsing
                    term_font="$(awk '/name="FontName"/ && match($0, /data="([^"]*)"/) {
                        print substr($0, RSTART+6, RLENGTH-7)}' "$ce_conf")"
                    break
                }
            done

            # Null-terminated contents in /proc/registry files triggers a Bash warning.
            [[ "$term_font" ]] || read -r term_font < \
                /proc/registry/HKEY_CURRENT_USER/Software/ConEmu/.Vanilla/FontName
        ;;
    esac
}

get_disk() {
    type -p df &>/dev/null ||
        { err "Disk requires 'df' to function. Install 'df' to get disk info."; return; }

    df_version=$(df --version 2>&1)

    case $df_version in
        *IMitv*)   df_flags=(-P -g) ;; # AIX
        *befhikm*) df_flags=(-P -k) ;; # IRIX
        *hiklnP*)  df_flags=(-h)    ;; # OpenBSD

        *Tracker*) # Haiku
            err "Your version of df cannot be used due to the non-standard flags"
            return
        ;;

        *) df_flags=(-P -h) ;;
    esac

    # Create an array called 'disks' where each element is a separate line from
    # df's output. We then unset the first element which removes the column titles.
    IFS=$'\n' read -d "" -ra disks <<< "$(df "${df_flags[@]}" "${disk_show[@]:-/}")"
    unset "disks[0]"

    # Stop here if 'df' fails to print disk info.
    [[ ${disks[*]} ]] || {
        err "Disk: df failed to print the disks, make sure the disk_show array is set properly."
        return
    }

    for disk in "${disks[@]}"; do
        # Create a second array and make each element split at whitespace this time.
        IFS=" " read -ra disk_info <<< "$disk"
        disk_perc=${disk_info[${#disk_info[@]} - 2]/\%}

        case $disk_percent in
            off) disk_perc=
        esac

        case $df_version in
            *befhikm*)
                disk=$((disk_info[${#disk_info[@]} - 4] / 1024 / 1024))G
                disk+=" / "
                disk+=$((disk_info[${#disk_info[@]} - 5] / 1024/ 1024))G
                disk+=${disk_perc:+ ($disk_perc%)}
            ;;

            *)
                disk=${disk_info[${#disk_info[@]} - 4]/i}
                disk+=" / "
                disk+=${disk_info[${#disk_info[@]} - 5]/i}
                disk+=${disk_perc:+ ($disk_perc%)}
            ;;
        esac

        case $disk_subtitle in
            name)
                disk_sub=${disk_info[*]::${#disk_info[@]} - 5}
            ;;

            dir)
                disk_sub=${disk_info[${#disk_info[@]} - 1]/*\/}
                disk_sub=${disk_sub:-${disk_info[${#disk_info[@]} - 1]}}
            ;;

            none) ;;

            *)
                disk_sub=${disk_info[${#disk_info[@]} - 1]}
            ;;
        esac

        case $disk_display in
            bar)     disk="$(bar "$disk_perc" "100")" ;;
            infobar) disk+=" $(bar "$disk_perc" "100")" ;;
            barinfo) disk="$(bar "$disk_perc" "100")${info_color} $disk" ;;
            perc)    disk="${disk_perc}% $(bar "$disk_perc" "100")" ;;
        esac

        # Append '(disk mount point)' to the subtitle.
        if [[ "$subtitle" ]]; then
            prin "$subtitle${disk_sub:+ ($disk_sub)}" "$disk"
        else
            prin "$disk_sub" "$disk"
        fi
    done
}

get_power_adapter() {
    case $os in
        "Mac OS X"|"macOS")
            power_adapter="$(pmset -g ac | awk '/Wattage/ {print $3}')"
            [[ "$power_adapter" ]] || power_adapter="not connected"
        ;;
        *)
            power_adapter="unknown"
        ;;
    esac
}

get_battery() {
    case $os in
        "Linux")
            # We use 'prin' here so that we can do multi battery support
            # with a single battery per line.
            for bat in "/sys/class/power_supply/"{BAT,axp288_fuel_gauge,CMB}*; do
                [[ -f ${bat}/capacity && -f ${bat}/status ]] || continue
                capacity="$(< "${bat}/capacity")"
                status="$(< "${bat}/status")"

                if [[ "$capacity" ]]; then
                    battery="${capacity}% [${status}]"

                    case $battery_display in
                        "bar")     battery="$(bar "$capacity" 100)" ;;
                        "infobar") battery+=" $(bar "$capacity" 100)" ;;
                        "barinfo") battery="$(bar "$capacity" 100)${info_color} ${battery}" ;;
                    esac

                    bat="${bat/*axp288_fuel_gauge}"
                    prin "${subtitle:+${subtitle}${bat: -1}}" "$battery"
                fi
            done
            return
        ;;

        "BSD")
            case $kernel_name in
                "FreeBSD"* | "DragonFly"*)
                    battery="$(acpiconf -i 0 | awk -F ':\t' '/Remaining capacity/ {print $2}')"
                    battery_state="$(acpiconf -i 0 | awk -F ':\t\t\t' '/State/ {print $2}')"
                ;;

                "NetBSD"*)
                    battery="$(envstat | awk '\\(|\\)' '/charge:/ {print $2}')"
                    battery="${battery/\.*/%}"
                ;;

                "OpenBSD"* | "Bitrig"*)
                    battery0full="$(sysctl -n   hw.sensors.acpibat0.watthour0\
                                                hw.sensors.acpibat0.amphour0)"
                    battery0full="${battery0full%% *}"

                    battery0now="$(sysctl -n    hw.sensors.acpibat0.watthour3\
                                                hw.sensors.acpibat0.amphour3)"
                    battery0now="${battery0now%% *}"

                    state="$(sysctl -n hw.sensors.acpibat0.raw0)"
                    state="${state##? (battery }"
                    state="${state%)*}"

                    [[ "${state}" == "charging" ]] && battery_state="charging"
                    [[ "$battery0full" ]] && \
                    battery="$((100 * ${battery0now/\.} / ${battery0full/\.}))%"
                ;;
            esac
        ;;

        "Mac OS X"|"macOS")
            battery="$(pmset -g batt | grep -o '[0-9]*%')"
            state="$(pmset -g batt | awk '/;/ {print $4}')"
            [[ "$state" == "charging;" ]] && battery_state="charging"
        ;;

        "Windows")
            battery="$(wmic Path Win32_Battery get EstimatedChargeRemaining)"
            battery="${battery/EstimatedChargeRemaining}"
            battery="$(trim "$battery")%"
            state="$(wmic /NameSpace:'\\root\WMI' Path BatteryStatus get Charging)"
            state="${state/Charging}"
            [[ "$state" == *TRUE* ]] && battery_state="charging"
        ;;

        "Interix")
            battery="$(/dev/fs/C/Windows/System32/wbem/WMIC.exe Path Win32_Battery get EstimatedChargeRemaining)"
            battery="${battery/EstimatedChargeRemaining}"
            battery="$(trim "$battery")%"
            state="$(/dev/fs/C/Windows/System32/wbem/WMIC.exe /NameSpace:'\\root\WMI' Path BatteryStatus get Charging)"
            state="${state/Charging}"
            [[ "$state" == *TRUE* ]] && battery_state="charging"
        ;;

        "Haiku")
            battery0full="$(awk -F '[^0-9]*' 'NR==2 {print $4}' /dev/power/acpi_battery/0)"
            battery0now="$(awk -F '[^0-9]*' 'NR==5 {print $4}' /dev/power/acpi_battery/0)"
            battery="$((battery0full * 100 / battery0now))%"
        ;;
    esac

    [[ "$battery_state" ]] && battery+=" Charging"

    case $battery_display in
        "bar")     battery="$(bar "${battery/\%*}" 100)" ;;
        "infobar") battery="${battery} $(bar "${battery/\%*}" 100)" ;;
        "barinfo") battery="$(bar "${battery/\%*}" 100)${info_color} ${battery}" ;;
    esac
}

get_local_ip() {
    case $os in
        "Linux" | "BSD" | "Solaris" | "illumos" | "AIX" | "IRIX")
            if [[ "${local_ip_interface[0]}" == "auto" ]]; then
                local_ip="$(ip route get 1 | awk -F'src' '{print $2; exit}')"
                local_ip="${local_ip/uid*}"
                [[ "$local_ip" ]] || local_ip="$(ifconfig -a | awk '/broadcast/ {print $2; exit}')"
            else
                for interface in "${local_ip_interface[@]}"; do
                    local_ip="$(ip addr show "$interface" 2> /dev/null |
                        awk '/inet / {print $2; exit}')"
                    local_ip="${local_ip/\/*}"
                    [[ "$local_ip" ]] ||
                        local_ip="$(ifconfig "$interface" 2> /dev/null |
                        awk '/broadcast/ {print $2; exit}')"
                    if [[ -n "$local_ip" ]]; then
                        prin "$interface" "$local_ip"
                    else
                        err "Local IP: Could not detect local ip for $interface"
                    fi
                done
            fi
        ;;

        "MINIX")
            local_ip="$(ifconfig | awk '{printf $3; exit}')"
        ;;

        "Mac OS X" | "macOS" | "iPhone OS")
            if [[ "${local_ip_interface[0]}" == "auto" ]]; then
                interface="$(route -n get 1 | awk -F': ' '/interface/ {printf $2; exit}')"
                local_ip="$(ifconfig "$interface" | grep "inet " | awk '{print $2}')"
            else
                for interface in "${local_ip_interface[@]}"; do
                    local_ip="$(ifconfig "$interface" | grep "inet " | awk '{print $2}')"
                    if [[ -n "$local_ip" ]]; then
                        prin "$interface" "$local_ip"
                    else
                        err "Local IP: Could not detect local ip for $interface"
                    fi
                done
            fi
        ;;

        "Windows" | "Interix")
            local_ip="$(ipconfig | awk -F ': ' '/IPv4 Address/ {printf $2 ", "}')"
            local_ip="${local_ip%\,*}"
        ;;

        "Haiku")
            local_ip="$(ifconfig | awk -F ': ' '/Bcast/ {print $2}')"
            local_ip="${local_ip/, Bcast}"
        ;;
    esac
}

get_public_ip() {
    if [[ -z "$public_ip_host" ]] && type -p dig >/dev/null; then
        public_ip="$(dig +time=1 +tries=1 +short myip.opendns.com @resolver1.opendns.com)"
       [[ "$public_ip" =~ ^\; ]] && unset public_ip
    fi

    if [[ -z "$public_ip_host" ]] && [[ -z "$public_ip" ]] && type -p drill >/dev/null; then
        public_ip="$(drill myip.opendns.com @resolver1.opendns.com | \
                     awk '/^myip\./ && $3 == "IN" {print $5}')"
    fi

    if [[ -z "$public_ip" ]] && type -p curl >/dev/null; then
        public_ip="$(curl -L --max-time "$public_ip_timeout" -w '\n' "$public_ip_host")"
    fi

    if [[ -z "$public_ip" ]] && type -p wget >/dev/null; then
        public_ip="$(wget -T "$public_ip_timeout" -qO- "$public_ip_host")"
    fi
}

get_users() {
    users="$(who | awk '!seen[$1]++ {printf $1 ", "}')"
    users="${users%\,*}"
}

get_locale() {
    locale="$sys_locale"
}

get_gpu_driver() {
    case $os in
        "Linux")
            gpu_driver="$(lspci -nnk | awk -F ': ' \
                          '/Display|3D|VGA/{nr[NR+2]}; NR in nr && $1~"nel driv" {printf $2 ", "}')"
            gpu_driver="${gpu_driver%, }"

            if [[ "$gpu_driver" == *"nvidia"* ]]; then
                gpu_driver="$(< /sys/module/nvidia/version)"
                gpu_driver="NVIDIA ${gpu_driver/  *}"
            fi
        ;;

        "Mac OS X"|"macOS")
            if [[ "$(kextstat | grep "GeForceWeb")" != "" ]]; then
                gpu_driver="NVIDIA Web Driver"
            else
                gpu_driver="macOS Default Graphics Driver"
            fi
        ;;
    esac
}

get_cols() {
    local blocks blocks2 cols

    if [[ "$color_blocks" == "on" ]]; then
        # Convert the width to space chars.
        printf -v block_width "%${block_width}s"

        # Generate the string.
        for ((block_range[0]; block_range[0]<=block_range[1]; block_range[0]++)); do
            case ${block_range[0]} in
                [0-7])
                    printf -v blocks  '%b\e[3%bm\e[4%bm%b' \
                        "$blocks" "${block_range[0]}" "${block_range[0]}" "$block_width"
                ;;

                *)
                    printf -v blocks2 '%b\e[38;5;%bm\e[48;5;%bm%b' \
                        "$blocks2" "${block_range[0]}" "${block_range[0]}" "$block_width"
                ;;
            esac
        done

        # Workaround for bright background colors in the Linux framebuffer console.
        (( block_range[1] < 16 )) && [[ "$TERM" == "linux" ]] &&
        printf -v blocks2 '\e[5m%b\e[25m' "$blocks2"

        # Convert height into spaces.
        printf -v block_spaces "%${block_height}s"

        # Convert the spaces into rows of blocks.
        if [ "${BASH_VERSION%%.*}" -lt 5 ]; then
            [[ "$blocks"  ]] && cols+="${block_spaces// /${blocks}[39;49mnl}"
            [[ "$blocks2" ]] && cols+="${block_spaces// /${blocks2}[0mnl}"
        else
            [[ "$blocks"  ]] && cols+="${block_spaces// /${blocks}\[39;49mnl}"
            [[ "$blocks2" ]] && cols+="${block_spaces// /${blocks2}\[0mnl}"
        fi

        # Determine the horizontal offset of the blocks.
        case $col_offset in
            "auto")  block_offset="$text_padding" ;;
            *)       block_offset="$col_offset" ;;
        esac

        # Add newlines to the string.
        cols=${cols%%nl}
        cols=${cols//nl/
[${block_offset}C${zws}}

        # Add block height to info height.
        ((info_height+=block_range[1]>7?block_height+2:block_height+1))

        printf '\n\e[%bC%b\n' "$block_offset" "${zws}${cols}"
    fi

    unset -v blocks blocks2 cols

    # Tell info() that we printed manually.
    prin=1
}

# IMAGES

image_backend() {
    [[ "$image_backend" != "off" ]] && ! type -p convert &>/dev/null && \
        { image_backend="ascii"; err "Image: Imagemagick not found, falling back to ascii mode."; }

    case ${image_backend:-off} in
        "ascii") print_ascii ;;
        "off") image_backend="off" ;;

        "caca" | "catimg" | "chafa" | "jp2a" | "iterm2" | "termpix" |\
        "tycat" | "w3m" | "sixel" | "pixterm" | "kitty" | "pot", | "ueberzug" |\
         "viu")
            get_image_source

            [[ ! -f "$image" ]] && {
                to_ascii "Image: '$image_source' doesn't exist, falling back to ascii mode."
                return
            }
            [[ "$image_backend" == "ueberzug" ]] && wait=true;

            get_window_size

            ((term_width < 1)) && {
                to_ascii "Image: Failed to find terminal window size."
                err "Image: Check the 'Images in the terminal' wiki page for more info,"
                return
            }

            printf '\e[2J\e[H'
            get_image_size
            make_thumbnail
            display_image || to_off "Image: $image_backend failed to display the image."
        ;;

        *)
            err "Image: Unknown image backend specified '$image_backend'."
            err "Image: Valid backends are: 'ascii', 'caca', 'catimg', 'chafa', 'jp2a', 'iterm2',
                                            'kitty', 'off', 'sixel', 'pot', 'pixterm', 'termpix',
                                            'tycat', 'w3m', 'viu')"
            err "Image: Falling back to ascii mode."
            print_ascii
        ;;
    esac

    # Set cursor position next image/ascii.
    [[ "$image_backend" != "off" ]] && printf '\e[%sA\e[9999999D' "${lines:-0}"
}

# From pull request #1220, this is a fast way to strip character codes
strip_escape_codes() {
    local input="${1//\"/\\\"}" output="" i char within_code=0
    for ((i=0; i < ${#input}; ++i)); do
        char="${input:i:1}"
        if (( within_code == 1 )); then
            case "${char}" in
                [a-zA-Z]) within_code=0 ;;
            esac
            continue
        fi
        if [[ "${char}" == $'\e' ]]; then
            within_code=1
            continue
        fi
        output+="${char}"
    done
    eval "$2='${output}'"
}

print_ascii() {
    if [[ -f "$image_source" && ! "$image_source" =~ (png|jpg|jpeg|jpe|svg|gif) ]]; then
        ascii_data="$(< "$image_source")"
    elif [[ "$image_source" == "ascii" || $image_source == auto ]]; then
        :
    else
        ascii_data="$image_source"
    fi

    # Set locale to get correct padding.
    LC_ALL="$sys_locale"

    # Calculate size of ascii file in line length / line count.
    if [ -n "$ascii_len" ] && [ -n "$ascii_lines" ]
    then
        lines=$ascii_lines
    else
        # shellcheck disable=SC2162
        # Reading without -r here is intentional. See https://github.com/dylanaraps/neofetch/pull/1543
        while IFS=$'\n' read line; do
            line=${line//█/ }
            # Fast method to strip codes
            strip_escape_codes "${line}" line
            # Use patterns to replace color codes that the above line did not catch
            line=${line//\\033\[*([0-9;])[JKmsu]/}
            line="$(printf %b "$line" | sed -E 's/'"$(printf %b '\x1B')"'\[*[0-9;]+[JKmsu]//g')"
            ((++lines,${#line}>ascii_len)) && ascii_len="${#line}"
        done <<< "${ascii_data//\$\{??\}}"
    fi

    # Fallback if file not found.
    ((lines==1)) && {
        lines=
        ascii_len=
        image_source=auto
        get_distro_ascii
        print_ascii
        return
    }

    # Colors.
    ascii_data="${ascii_data//\$\{c1\}/$c1}"
    ascii_data="${ascii_data//\$\{c2\}/$c2}"
    ascii_data="${ascii_data//\$\{c3\}/$c3}"
    ascii_data="${ascii_data//\$\{c4\}/$c4}"
    ascii_data="${ascii_data//\$\{c5\}/$c5}"
    ascii_data="${ascii_data//\$\{c6\}/$c6}"

    ((text_padding=ascii_len+gap))
    printf '%b\n' "$ascii_data${reset}"
    LC_ALL=C
}

get_image_source() {
    case $image_source in
        "auto" | "wall" | "wallpaper")
            get_wallpaper
        ;;

        *)
            # Get the absolute path.
            image_source="$(get_full_path "$image_source")"

            if [[ -d "$image_source" ]]; then
                shopt -s nullglob
                files=("${image_source%/}"/*.{png,jpg,jpeg,jpe,gif,svg})
                shopt -u nullglob
                image="${files[RANDOM % ${#files[@]}]}"

            else
                image="$image_source"
            fi
        ;;
    esac

    err "Image: Using image '$image'"
}

get_wallpaper() {
    case $os in
        "Mac OS X"|"macOS")
            image="$(osascript <<END
                     tell application "System Events" to picture of current desktop
END
)"
        ;;

        "Windows")
            case $distro in
                "Windows XP")
                    image="/c/Documents and Settings/${USER}"
                    image+="/Local Settings/Application Data/Microsoft/Wallpaper1.bmp"

                    [[ "$kernel_name" == *CYGWIN* ]] && image="/cygdrive${image}"
                ;;

                "Windows"*)
                    image="${APPDATA}/Microsoft/Windows/Themes/TranscodedWallpaper.jpg"
                ;;
            esac
        ;;

        *)
            # Get DE if user has disabled the function.
            ((de_run != 1)) && get_de

            type -p wal >/dev/null && [[ -f "${HOME}/.cache/wal/wal" ]] && \
                { image="$(< "${HOME}/.cache/wal/wal")"; return; }

            case $de in
                "MATE"*)
                    image="$(gsettings get org.mate.background picture-filename)"
                ;;

                "Xfce"*)
                    image="$(xfconf-query -c xfce4-desktop -p \
                             "/backdrop/screen0/monitor0/workspace0/last-image")"
                ;;

                "Cinnamon"*)
                    image="$(gsettings get org.cinnamon.desktop.background picture-uri)"
                    image="$(decode_url "$image")"
                ;;

                "GNOME"*)
                    image="$(gsettings get org.gnome.desktop.background picture-uri)"
                    image="$(decode_url "$image")"
                ;;

                "Plasma"*)
                    image=$XDG_CONFIG_HOME/plasma-org.kde.plasma.desktop-appletsrc
                    image=$(awk -F '=' '$1 == "Image" { print $2 }' "$image")
                ;;

                "Cutefish"*)
                    image="$XDG_CONFIG_HOME/cutefishos/theme.conf"
                    image="$(awk -F '=' '$1 == "Wallpaper" {print $2}' "$image")"
                ;;

                "LXQt"*)
                    image="$XDG_CONFIG_HOME/pcmanfm-qt/lxqt/settings.conf"
                    image="$(awk -F '=' '$1 == "Wallpaper" {print $2}' "$image")"
                ;;

                *)
                    if type -p feh >/dev/null && [[ -f "${HOME}/.fehbg" ]]; then
                        image="$(awk -F\' '/feh/ {printf $(NF-1)}' "${HOME}/.fehbg")"

                    elif type -p setroot >/dev/null && \
                         [[ -f "${XDG_CONFIG_HOME}/setroot/.setroot-restore" ]]; then
                        image="$(awk -F\' '/setroot/ {printf $(NF-1)}' \
                                 "${XDG_CONFIG_HOME}/setroot/.setroot-restore")"

                    elif type -p nitrogen >/dev/null; then
                        image="$(awk -F'=' '/file/ {printf $2;exit;}' \
                                 "${XDG_CONFIG_HOME}/nitrogen/bg-saved.cfg")"

                    else
                        image="$(gsettings get org.gnome.desktop.background picture-uri)"
                        image="$(decode_url "$image")"
                    fi
                ;;
            esac

            # Strip un-needed info from the path.
            image="${image/file:\/\/}"
            image="$(trim_quotes "$image")"
        ;;
    esac

    # If image is an xml file, don't use it.
    [[ "${image/*\./}" == "xml" ]] && image=""
}

get_w3m_img_path() {
    # Find w3m-img path.
    shopt -s nullglob
    w3m_paths=({/usr/{local/,},~/.nix-profile/}{lib,libexec,lib64,libexec64}/w3m/w3mi*)
    shopt -u nullglob

    [[ -x "${w3m_paths[0]}" ]] && \
        { w3m_img_path="${w3m_paths[0]}"; return; }

    err "Image: w3m-img wasn't found on your system"
}

get_window_size() {
    # This functions gets the current window size in
    # pixels.
    #
    # We first try to use the escape sequence "\033[14t"
    # to get the terminal window size in pixels. If this
    # fails we then fallback to using "xdotool" or other
    # programs.

    # Tmux has a special way of reading escape sequences
    # so we have to use a slightly different sequence to
    # get the terminal size.
    if [[ "$image_backend" == "tycat" ]]; then
        printf '%b' '\e}qs\000'

    elif [[ -z $VTE_VERSION ]]; then
        case ${TMUX:-null} in
            "null") printf '%b' '\e[14t' ;;
            *)      printf '%b' '\ePtmux;\e\e[14t\e\\ ' ;;
        esac
    fi

    # The escape codes above print the desired output as
    # user input so we have to use read to store the out
    # -put as a variable.
    # The 3 second timeout is required for slow/remote
    # sessions.
    #
    # False positive.
    # shellcheck disable=2141
    IFS=';t' read -d t -t 3 -sra term_size
    unset IFS

    # Split the string into height/width.
    if [[ "$image_backend" == "tycat" ]]; then
        term_width="$((term_size[2] * term_size[0]))"
        term_height="$((term_size[3] * term_size[1]))"

    else
        term_height="${term_size[1]}"
        term_width="${term_size[2]}"
    fi

    # Get terminal width/height.
    if (( "${term_width:-0}" < 50 )) && [[ "$DISPLAY" && $os != "Mac OS X" && $os != "macOS" ]]; then
        if type -p xdotool &>/dev/null; then
            IFS=$'\n' read -d "" -ra win \
                <<< "$(xdotool getactivewindow getwindowgeometry --shell %1)"
            term_width="${win[3]/WIDTH=}"
            term_height="${win[4]/HEIGHT=}"

        elif type -p xwininfo &>/dev/null; then
            # Get the focused window's ID.
            if type -p xdo &>/dev/null; then
                current_window="$(xdo id)"

            elif type -p xprop &>/dev/null; then
                current_window="$(xprop -root _NET_ACTIVE_WINDOW)"
                current_window="${current_window##* }"

            elif type -p xdpyinfo &>/dev/null; then
                current_window="$(xdpyinfo | grep -F "focus:")"
                current_window="${current_window/*window }"
                current_window="${current_window/,*}"
            fi

            # If the ID was found get the window size.
            if [[ "$current_window" ]]; then
                term_size=("$(xwininfo -id "$current_window")")
                term_width="${term_size[0]#*Width: }"
                term_width="${term_width/$'\n'*}"
                term_height="${term_size[0]/*Height: }"
                term_height="${term_height/$'\n'*}"
            fi
        fi
    fi

    term_width="${term_width:-0}"
}


get_term_size() {
    # Get the terminal size in cells.
    read -r lines columns <<< "$(stty size)"

    # Calculate font size.
    font_width="$((term_width / columns))"
    font_height="$((term_height / lines))"
}

get_image_size() {
    # This functions determines the size to make the thumbnail image.
    get_term_size

    case $image_size in
        "auto")
            image_size="$((columns * font_width / 2))"
            term_height="$((term_height - term_height / 4))"

            ((term_height < image_size)) && \
                image_size="$term_height"
        ;;

        *"%")
            percent="${image_size/\%}"
            image_size="$((percent * term_width / 100))"

            (((percent * term_height / 50) < image_size)) && \
                image_size="$((percent * term_height / 100))"
        ;;

        "none")
            # Get image size so that we can do a better crop.
            read -r width height <<< "$(identify -format "%w %h" "$image")"

            while ((width >= (term_width / 2) || height >= term_height)); do
                ((width=width/2,height=height/2))
            done

            crop_mode="none"
        ;;

        *)  image_size="${image_size/px}" ;;
    esac

    # Check for terminal padding.
    [[ "$image_backend" == "w3m" ]] && term_padding

    width="${width:-$image_size}"
    height="${height:-$image_size}"
    text_padding="$(((width + padding + xoffset) / font_width + gap))"
}

make_thumbnail() {
    # Name the thumbnail using variables so we can
    # use it later.
    image_name="${crop_mode}-${crop_offset}-${width}-${height}-${image//\/}"

    # Handle file extensions.
    case ${image##*.} in
        "eps"|"pdf"|"svg"|"gif"|"png")
            image_name+=".png" ;;
        *)  image_name+=".jpg" ;;
    esac

    # Create the thumbnail dir if it doesn't exist.
    mkdir -p "${thumbnail_dir:=${XDG_CACHE_HOME:-${HOME}/.cache}/thumbnails/neofetch}"

    if [[ ! -f "${thumbnail_dir}/${image_name}" ]]; then
        # Get image size so that we can do a better crop.
        [[ -z "$size" ]] && {
            read -r og_width og_height <<< "$(identify -format "%w %h" "$image")"
            ((og_height > og_width)) && size="$og_width" || size="$og_height"
        }

        case $crop_mode in
            "fit")
                c="$(convert "$image" \
                    -colorspace srgb \
                    -format "%[pixel:p{0,0}]" info:)"

                convert \
                    -background none \
                    "$image" \
                    -trim +repage \
                    -gravity south \
                    -background "$c" \
                    -extent "${size}x${size}" \
                    -scale "${width}x${height}" \
                    "${thumbnail_dir}/${image_name}"
            ;;

            "fill")
                convert \
                    -background none \
                    "$image" \
                    -trim +repage \
                    -scale "${width}x${height}^" \
                    -extent "${width}x${height}" \
                    "${thumbnail_dir}/${image_name}"
            ;;

            "none")
                cp "$image" "${thumbnail_dir}/${image_name}"
            ;;

            *)
                convert \
                    -background none \
                    "$image" \
                    -strip \
                    -gravity "$crop_offset" \
                    -crop "${size}x${size}+0+0" \
                    -scale "${width}x${height}" \
                    "${thumbnail_dir}/${image_name}"
            ;;
        esac
    fi

    # The final image.
    image="${thumbnail_dir}/${image_name}"
}

display_image() {
    case $image_backend in
        "caca")
            img2txt \
                -W "$((width / font_width))" \
                -H "$((height / font_height))" \
                --gamma=0.6 \
            "$image"
        ;;


        "ueberzug")
            if [ "$wait" = true ];then
                wait=false;
            else
                ueberzug layer --parser bash 0< <(
                    declare -Ap ADD=(\
                        [action]="add"\
                        [identifier]="neofetch"\
                        [x]=$xoffset [y]=$yoffset\
                        [path]=$image\
                    )
                    read -rs
                )
            fi
        ;;

        "catimg")
            catimg -w "$((width*catimg_size / font_width))" -r "$catimg_size" "$image"
        ;;

        "chafa")
            chafa --stretch --size="$((width / font_width))x$((height / font_height))" "$image"
        ;;

        "jp2a")
            jp2a \
                --colors \
                --width="$((width / font_width))" \
                --height="$((height / font_height))" \
            "$image"
        ;;

        "kitty")
            kitty +kitten icat \
                --align left \
                --place "$((width/font_width))x$((height/font_height))@${xoffset}x${yoffset}" \
            "$image"
        ;;

        "pot")
            pot \
                "$image" \
                --size="$((width / font_width))x$((height / font_height))"
        ;;

        "pixterm")
            pixterm \
                -tc "$((width / font_width))" \
                -tr "$((height / font_height))" \
            "$image"
        ;;

        "sixel")
            img2sixel -I \
                -w "$width" \
                -h "$height" \
            "$image"
        ;;

        "termpix")
            termpix \
                --width "$((width / font_width))" \
                --height "$((height / font_height))" \
            "$image"
        ;;

        "iterm2")
            printf -v iterm_cmd '\e]1337;File=width=%spx;height=%spx;inline=1:%s' \
                "$width" "$height" "$(base64 < "$image")"

            # Tmux requires an additional escape sequence for this to work.
            [[ -n "$TMUX" ]] && printf -v iterm_cmd '\ePtmux;\e%b\e'\\ "$iterm_cmd"

            printf '%b\a\n' "$iterm_cmd"
        ;;

        "tycat")
            tycat \
                -g "${width}x${height}" \
            "$image"
        ;;

        "viu")
            viu \
                -t -w "$((width / font_width))" -h "$((height / font_height))" \
            "$image"
        ;;

        "w3m")
            get_w3m_img_path
            zws='\xE2\x80\x8B\x20'

            # Add a tiny delay to fix issues with images not
            # appearing in specific terminal emulators.
            ((bash_version>3)) && sleep 0.05
            printf '%b\n%s;\n%s\n' "0;1;$xoffset;$yoffset;$width;$height;;;;;$image" 3 4 |\
            "${w3m_img_path:-false}" -bg "$background_color" &>/dev/null
        ;;
    esac
}

to_ascii() {
    err "$1"
    image_backend="ascii"
    print_ascii

    # Set cursor position next image/ascii.
    printf '\e[%sA\e[9999999D' "${lines:-0}"
}

to_off() {
    err "$1"
    image_backend="off"
    text_padding=
}


# TEXT FORMATTING

info() {
    # Save subtitle value.
    [[ "$2" ]] && subtitle="$1"

    # Make sure that $prin is unset.
    unset -v prin

    # Call the function.
    "get_${2:-$1}"

    # If the get_func function called 'prin' directly, stop here.
    [[ "$prin" ]] && return

    # Update the variable.
    if [[ "$2" ]]; then
        output="$(trim "${!2}")"
    else
        output="$(trim "${!1}")"
    fi

    if [[ "$2" && "${output// }" ]]; then
        prin "$1" "$output"

    elif [[ "${output// }" ]]; then
        prin "$output"

    else
        err "Info: Couldn't detect ${1}."
    fi

    unset -v subtitle
}

prin() {
    # If $2 doesn't exist we format $1 as info.
    if [[ "$(trim "$1")" && "$2" ]]; then
        [[ "$json" ]] && { printf '    %s\n' "\"${1}\": \"${2}\","; return; }

        string="${1}${2:+: $2}"
    else
        string="${2:-$1}"
        local subtitle_color="$info_color"
    fi

    string="$(trim "${string//$'\e[0m'}")"
    length="$(strip_sequences "$string")"
    length="${#length}"

    # Format the output.
    string="${string/:/${reset}${colon_color}${separator:=:}${info_color}}"
    string="${subtitle_color}${bold}${string}"

    # Print the info.
    printf '%b\n' "${text_padding:+\e[${text_padding}C}${zws}${string//\\n}${reset} "

    # Calculate info height.
    ((++info_height))

    # Log that prin was used.
    prin=1
}

get_underline() {
    [[ "$underline_enabled" == "on" ]] && {
        printf -v underline "%${length}s"
        printf '%b%b\n' "${text_padding:+\e[${text_padding}C}${zws}${underline_color}" \
                        "${underline// /$underline_char}${reset} "
    }

    ((++info_height))
    length=
    prin=1
}

get_bold() {
    case $ascii_bold in
        "on")  ascii_bold='\e[1m' ;;
        "off") ascii_bold="" ;;
    esac

    case $bold in
        "on")  bold='\e[1m' ;;
        "off") bold="" ;;
    esac
}

trim() {
    set -f
    # shellcheck disable=2048,2086
    set -- $*
    printf '%s\n' "${*//[[:space:]]/}"
    set +f
}

trim_quotes() {
    trim_output="${1//\'}"
    trim_output="${trim_output//\"}"
    printf "%s" "$trim_output"
}

strip_sequences() {
    strip="${1//$'\e'\[*([0-9])*(;*([0-9]))m}"
    strip="${strip//\\e\[*([0-9])*(;*([0-9]))m}"

    printf '%s\n' "$strip"
}

# COLORS

set_colors() {
    c1="$(color "$1")${ascii_bold}"
    c2="$(color "$2")${ascii_bold}"
    c3="$(color "$3")${ascii_bold}"
    c4="$(color "$4")${ascii_bold}"
    c5="$(color "$5")${ascii_bold}"
    c6="$(color "$6")${ascii_bold}"

    [[ "$color_text" != "off" ]] && set_text_colors "$@"
}

set_text_colors() {
    if [[ "${colors[0]}" == "distro" ]]; then
        title_color="$(color "$1")"
        at_color="$reset"
        underline_color="$reset"
        subtitle_color="$(color "$2")"
        colon_color="$reset"
        info_color="$reset"

        # If the ascii art uses 8 as a color, make the text the fg.
        ((${1:-1} == 8)) && title_color="$reset"
        ((${2:-7} == 8)) && subtitle_color="$reset"

        # If the second color is white use the first for the subtitle.
        ((${2:-7} == 7)) && subtitle_color="$(color "$1")"
        ((${1:-1} == 7)) && title_color="$reset"
    else
        title_color="$(color "${colors[0]}")"
        at_color="$(color "${colors[1]}")"
        underline_color="$(color "${colors[2]}")"
        subtitle_color="$(color "${colors[3]}")"
        colon_color="$(color "${colors[4]}")"
        info_color="$(color "${colors[5]}")"
    fi

    # Bar colors.
    if [[ "$bar_color_elapsed" == "distro" ]]; then
        bar_color_elapsed="$(color fg)"
    else
        bar_color_elapsed="$(color "$bar_color_elapsed")"
    fi

    if [[ "$bar_color_total" == "distro" ]]; then
        bar_color_total="$(color fg)"
    else
        bar_color_total="$(color "$bar_color_total")"
    fi
}

color() {
    case $1 in
        [0-7]) printf '%b\e[3%sm'   "$reset" "$1" ;;
        "fg")  printf '%b'          "$reset" ;;
        "#"*)
            local rgb="${1//#}"
            rgb="$((0x$rgb))"
            printf '\e[38;2;%b;%b;%bm' "$((rgb >> 16))" "$(((rgb >> 8) & 0xff))" "$((rgb & 0xff))"
        ;;

        *)        printf '\e[38;5;%bm' "$1" ;;
    esac
}

# OTHER

stdout() {
    image_backend="off"
    unset subtitle_color colon_color info_color underline_color bold title_color at_color \
          text_padding zws reset color_blocks bar_color_elapsed bar_color_total \
          c1 c2 c3 c4 c5 c6 c7 c8
}

err() {
    err+="$(color 1)[!]${reset} $1
"
}

get_full_path() {
    # This function finds the absolute path from a relative one.
    # For example "Pictures/Wallpapers" --> "/home/dylan/Pictures/Wallpapers"

    # If the file exists in the current directory, stop here.
    [[ -f "${PWD}/${1}" ]] && { printf '%s\n' "${PWD}/${1}"; return; }

    ! cd "${1%/*}" && {
        err "Error: Directory '${1%/*}' doesn't exist or is inaccessible"
        err "       Check that the directory exists or try another directory."
        exit 1
    }

    local full_dir="${1##*/}"

    # Iterate down a (possible) chain of symlinks.
    while [[ -L "$full_dir" ]]; do
        full_dir="$(readlink "$full_dir")"
        cd "${full_dir%/*}" || exit
        full_dir="${full_dir##*/}"
    done

    # Final directory.
    full_dir="$(pwd -P)/${1/*\/}"

    [[ -e "$full_dir" ]] && printf '%s\n' "$full_dir"
}

get_user_config() {
    # --config /path/to/config.conf
    if [[ -f "$config_file" ]]; then
        source "$config_file"
        err "Config: Sourced user config. (${config_file})"
        return

    elif [[ -f "${XDG_CONFIG_HOME}/neofetch/config.conf" ]]; then
        source "${XDG_CONFIG_HOME}/neofetch/config.conf"
        err "Config: Sourced user config.    (${XDG_CONFIG_HOME}/neofetch/config.conf)"

    elif [[ -f "${XDG_CONFIG_HOME}/neofetch/config" ]]; then
        source "${XDG_CONFIG_HOME}/neofetch/config"
        err "Config: Sourced user config.    (${XDG_CONFIG_HOME}/neofetch/config)"

    elif [[ -z "$no_config" ]]; then
        config_file="${XDG_CONFIG_HOME}/neofetch/config.conf"

        # The config file doesn't exist, create it.
        mkdir -p "${XDG_CONFIG_HOME}/neofetch/"
        printf '%s\n' "$config" > "$config_file"
    fi
}

bar() {
    # Get the values.
    elapsed="$(($1 * bar_length / $2))"

    # Create the bar with spaces.
    printf -v prog  "%${elapsed}s"
    printf -v total "%$((bar_length - elapsed))s"

    # Set the colors and swap the spaces for $bar_char_.
    bar+="${bar_color_elapsed}${prog// /${bar_char_elapsed}}"
    bar+="${bar_color_total}${total// /${bar_char_total}}"

    # Borders.
    [[ "$bar_border" == "on" ]] && \
        bar="$(color fg)[${bar}$(color fg)]"

    printf "%b" "${bar}${info_color}"
}

cache() {
    if [[ "$2" ]]; then
        mkdir -p "${cache_dir}/neofetch"
        printf "%s" "${1/*-}=\"$2\"" > "${cache_dir}/neofetch/${1/*-}"
    fi
}

get_cache_dir() {
    if [[ "$TMPDIR" ]]; then
        cache_dir="$TMPDIR"
    else
        cache_dir="/tmp"
    fi
}

kde_config_dir() {
    # If the user is using KDE get the KDE
    # configuration directory.
    if [[ "$kde_config_dir" ]]; then
        return

    elif type -p kf5-config &>/dev/null; then
        kde_config_dir="$(kf5-config --path config)"

    elif type -p kde4-config &>/dev/null; then
        kde_config_dir="$(kde4-config --path config)"

    elif type -p kde-config &>/dev/null; then
        kde_config_dir="$(kde-config --path config)"

    elif [[ -d "${HOME}/.kde4" ]]; then
        kde_config_dir="${HOME}/.kde4/share/config"

    elif [[ -d "${HOME}/.kde3" ]]; then
        kde_config_dir="${HOME}/.kde3/share/config"
    fi

    kde_config_dir="${kde_config_dir/$'/:'*}"
}

tde_config_dir() {
    if [[ "$tde_config_dir" ]]; then
        return

    elif type -p tde-config &>/dev/null; then
        tde_config_dir="$(tde-config --path config)"

    elif [[ -d "${HOME}/.configtde" ]]; then
        tde_config_dir="${HOME}/.configtde"

    fi

    tde_config_dir="${tde_config_dir/$'/:'*}"
}

fly_config_file() {
    # Return main path the fly config file
    fly_config_file=${HOME}/.fly/theme/current.themerc
}

term_padding() {
    # Get terminal padding to properly align cursor.
    [[ -z "$term" ]] && get_term

    case $term in
        urxvt*|rxvt-unicode)
            [[ $xrdb ]] || xrdb=$(xrdb -query)

            [[ $xrdb != *internalBorder:* ]] &&
                return

            padding=${xrdb/*internalBorder:}
            padding=${padding/$'\n'*}

            [[ $padding =~ ^[0-9]+$ ]] ||
                padding=
        ;;
    esac
}

dynamic_prompt() {
    [[ "$image_backend" == "off" ]]   && { printf '\n'; return; }
    [[ "$image_backend" != "ascii" ]] && ((lines=(height + yoffset) / font_height + 1))
    [[ "$image_backend" == "w3m" ]]   && ((lines=lines + padding / font_height + 1))

    # If the ascii art is taller than the info.
    ((lines=lines>info_height?lines-info_height+1:1))

    printf -v nlines "%${lines}s"
    printf "%b" "${nlines// /\\n}"
}

cache_uname() {
    # Cache the output of uname so we don't
    # have to spawn it multiple times.
    IFS=" " read -ra uname <<< "$(uname -srm)"

    kernel_name="${uname[0]}"
    kernel_version="${uname[1]}"
    kernel_machine="${uname[2]}"

    if [[ "$kernel_name" == "Darwin" ]] ||
       [[ "$kernel_name" == "FreeBSD" && -f /System/Library/CoreServices/SystemVersion.plist ]]; then
        # macOS can report incorrect versions unless this is 0.
        # https://github.com/dylanaraps/neofetch/issues/1607
        export SYSTEM_VERSION_COMPAT=0

        IFS=$'\n' read -d "" -ra sw_vers <<< "$(awk -F'<|>' '/key|string/ {print $3}' \
                            "/System/Library/CoreServices/SystemVersion.plist")"
        for ((i=0;i<${#sw_vers[@]};i+=2)) {
            case ${sw_vers[i]} in
                ProductName)          darwin_name=${sw_vers[i+1]} ;;
                ProductFamily)        darwin_family=${sw_vers[i+1]} ;;
                ProductVersion)       osx_version=${sw_vers[i+1]} ;;
                ProductBuildVersion)  osx_build=${sw_vers[i+1]}   ;;
            esac
        }
    fi
}

get_ppid() {
    # Get parent process ID of PID.
    case $os in
        "Windows")
            ppid="$(ps -p "${1:-$PPID}" | awk '{printf $2}')"
            ppid="${ppid/PPID}"
        ;;

        "Linux")
            ppid="$(grep -i -F "PPid:" "/proc/${1:-$PPID}/status")"
            ppid="$(trim "${ppid/PPid:}")"
        ;;

        *)
            ppid="$(ps -p "${1:-$PPID}" -o ppid=)"
        ;;
    esac

    printf "%s" "$ppid"
}

get_process_name() {
    # Get PID name.
    case $os in
        "Windows")
            name="$(ps -p "${1:-$PPID}" | awk '{printf $8}')"
            name="${name/COMMAND}"
            name="${name/*\/}"
        ;;

        "Linux")
            read -rd $'\00' name < "/proc/${1:-$PPID}/cmdline"
        ;;

        *)
            name="$(ps -p "${1:-$PPID}" -o comm=)"
        ;;
    esac

    printf "%s" "$name"
}

decode_url() {
    decode="${1//+/ }"
    printf "%b" "${decode//%/\\x}"
}

# FINISH UP

usage() { printf "%s" "\
Usage: neofetch func_name --option \"value\" --option \"value\"

Neofetch is a CLI system information tool written in BASH. Neofetch
displays information about your system next to an image, your OS logo,
or any ASCII file of your choice.

NOTE: Every launch flag has a config option.

Options:

INFO:
    func_name                   Specify a function name (second part of info() from config) to
                                quickly display only that function's information.

                                Example: neofetch uptime --uptime_shorthand tiny

                                Example: neofetch uptime disk wm memory

                                This can be used in bars and scripts like so:

                                memory=\"\$(neofetch memory)\"; memory=\"\${memory##*: }\"

                                For multiple outputs at once (each line of info in an array):

                                IFS=\$'\\n' read -d \"\" -ra info < <(neofetch memory uptime wm)

                                info=(\"\${info[@]##*: }\")

    --disable infoname          Allows you to disable an info line from appearing
                                in the output. 'infoname' is the function name from the
                                'print_info()' function inside the config file.
                                For example: 'info \"Memory\" memory' would be '--disable memory'

                                NOTE: You can supply multiple args. eg. 'neofetch --disable cpu gpu'

    --title_fqdn on/off         Hide/Show Fully Qualified Domain Name in title.
    --package_managers on/off   Hide/Show Package Manager names. (on, tiny, off)
    --package_separate on/off   Whether to separate system/user modes for supported package managers
    --package_minimal           Reduce output of packages list by not showing programming language package managers or Steam games
    --os_arch on/off            Hide/Show OS architecture.
    --speed_type type           Change the type of cpu speed to display.
                                Possible values: current, min, max, bios,
                                scaling_current, scaling_min, scaling_max

                                NOTE: This only supports Linux with cpufreq.

    --speed_shorthand on/off    Whether or not to show decimals in CPU speed.

                                NOTE: This flag is not supported in systems with CPU speed less than
                                1 GHz.

    --cpu_brand on/off          Enable/Disable CPU brand in output.
    --cpu_cores type            Whether or not to display the number of CPU cores
                                Possible values: logical, physical, off

                                NOTE: 'physical' doesn't work on BSD.

    --cpu_speed on/off          Hide/Show cpu speed.
    --cpu_temp C/F/off          Hide/Show cpu temperature.

                                NOTE: This only works on Linux and BSD.

                                NOTE: For FreeBSD and NetBSD-based systems, you need to enable
                                coretemp kernel module. This only supports newer Intel processors.

    --distro_shorthand on/off   Shorten the output of distro (on, tiny, off)

                                NOTE: This option won't work in Windows (Cygwin)

    --kernel_shorthand on/off   Shorten the output of kernel

                                NOTE: This option won't work in BSDs (except PacBSD and PC-BSD)

    --uptime_shorthand on/off   Shorten the output of uptime (on, tiny, off)
    --refresh_rate on/off       Whether to display the refresh rate of each monitor
                                Unsupported on Windows
    --gpu_brand on/off          Enable/Disable GPU brand in output. (AMD/NVIDIA/Intel)
    --gpu_type type             Which GPU to display. (all, dedicated, integrated)

                                NOTE: This only supports Linux.

    --de_version on/off         Show/Hide Desktop Environment version
    --gtk_shorthand on/off      Shorten output of gtk theme/icons
    --gtk2 on/off               Enable/Disable gtk2 theme/font/icons output
    --gtk3 on/off               Enable/Disable gtk3 theme/font/icons output
    --shell_path on/off         Enable/Disable showing \$SHELL path
    --shell_version on/off      Enable/Disable showing \$SHELL version
    --editor_path on/off        Enable/Disable showing \$EDITOR path
    --editor_version on/off     Enable/Disable showing \$EDITOR version
    --disk_show value           Which disks to display.
                                Possible values: '/', '/dev/sdXX', '/path/to/mount point'

                                NOTE: Multiple values can be given. (--disk_show '/' '/dev/sdc1')

    --disk_subtitle type        What information to append to the Disk subtitle.
                                Takes: name, mount, dir, none

                                'name' shows the disk's name (sda1, sda2, etc)

                                'mount' shows the disk's mount point (/, /mnt/Local Disk, etc)

                                'dir' shows the basename of the disks's path. (/, Local Disk, etc)

                                'none' shows only 'Disk' or the configured title.

    --disk_percent on/off       Hide/Show disk percent.

    --ip_host url               URL to query for public IP
    --ip_timeout int            Public IP timeout (in seconds).
    --ip_interface value        Interface(s) to use for local IP
    --song_format format        Print the song data in a specific format (see config file).
    --song_shorthand on/off     Print the Artist/Album/Title on separate lines.
    --memory_percent on/off     Display memory percentage.
    --memory_unit (k/m/g/t)ib   Memory output unit.
    --memory_precision integer  Change memory output precision. (≥0, default=2)
    --music_player player-name  Manually specify a player to use.
                                Available values are listed in the config file

TEXT FORMATTING:
    --colors x x x x x x        Changes the text colors in this order:
                                title, @, underline, subtitle, colon, info
    --underline on/off          Enable/Disable the underline.
    --underline_char char       Character to use when underlining title
    --bold on/off               Enable/Disable bold text
    --separator string          Changes the default ':' separator to the specified string.

COLOR BLOCKS:
    --color_blocks on/off       Enable/Disable the color blocks
    --col_offset auto/num       Left-padding of color blocks
    --block_width num           Width of color blocks in spaces
    --block_height num          Height of color blocks in lines
    --block_range num num       Range of colors to print as blocks

BARS:
    --bar_char 'elapsed char' 'total char'
                                Characters to use when drawing bars.
    --bar_border on/off         Whether or not to surround the bar with '[]'
    --bar_length num            Length in spaces to make the bars.
    --bar_colors num num        Colors to make the bar.
                                Set in this order: elapsed, total
    --memory_display mode       Bar mode.
                                Possible values: bar, infobar, barinfo, off
    --battery_display mode      Bar mode.
                                Possible values: bar, infobar, barinfo, off
    --disk_display mode         Bar mode.
                                Possible values: bar, infobar, barinfo, off

IMAGE BACKEND:
    --backend backend           Which image backend to use.
                                Possible values: 'ascii', 'caca', 'catimg', 'chafa', 'jp2a',
                                'iterm2', 'off', 'sixel', 'tycat', 'w3m', 'kitty', 'viu'
    --source source             Which image or ascii file to use.
                                Possible values: 'auto', 'ascii', 'wallpaper', '/path/to/img',
                                '/path/to/ascii', '/path/to/dir/', 'command output' [ascii]

    --ascii source              Shortcut to use 'ascii' backend.

                                NEW: neofetch --ascii \"\$(fortune | cowsay -W 30)\"

    --caca source               Shortcut to use 'caca' backend.
    --catimg source             Shortcut to use 'catimg' backend.
    --chafa source              Shortcut to use 'chafa' backend.
    --iterm2 source             Shortcut to use 'iterm2' backend.
    --jp2a source               Shortcut to use 'jp2a' backend.
    --kitty source              Shortcut to use 'kitty' backend.
    --pot source                Shortcut to use 'pot' backend.
    --pixterm source            Shortcut to use 'pixterm' backend.
    --sixel source              Shortcut to use 'sixel' backend.
    --termpix source            Shortcut to use 'termpix' backend.
    --tycat source              Shortcut to use 'tycat' backend.
    --w3m source                Shortcut to use 'w3m' backend.
    --ueberzug source           Shortcut to use 'ueberzug' backend
    --viu source                Shortcut to use 'viu' backend
    --off                       Shortcut to use 'off' backend (Disable ascii art).

    NOTE: 'source; can be any of the following: 'auto', 'ascii', 'wallpaper', '/path/to/img',
    '/path/to/ascii', '/path/to/dir/'

ASCII:
    --ascii_colors x x x x x x  Colors to print the ascii art
    --ascii_distro distro       Which Distro's ascii art to print

                                NOTE: Adélie, aerOS, Afterglow, AIX, AlmaLinux, Alpine, Alter,
                                Amazon, AmogOS, Anarchy, Android, Antergos, antiX, AOSC OS, Aperio
                                GNU/Linux, Aperture, Apricity, Arch, ArchBox, Archcraft,
                                archcraft_ascii, archcraft_minimal, ARCHlabs, ArchMerge, ArchStrike,
                                ArcoLinux, ArseLinux, Artix, Arya, Asahi, AsteroidOS, astOS, Astra
                                Linux, Athena, azos, Bedrock, BigLinux, Bitrig, BlackArch,
                                blackPanther, BLAG, BlankOn, BlueLight, Bodhi, bonsai, BSD,
                                BunsenLabs, CachyOS, Calculate, CalinixOS, Carbs, CBL-Mariner,
                                CelOS, Center, CentOS, Chakra, ChaletOS, Chapeau, Chimera, ChonkySealOS,
                                Chrom, Cleanjaro, Clear Linux OS, ClearOS, Clover, Cobalt, Condres,
                                Container Linux by CoreOS, CRUX, Crystal Linux, Cucumber,
                                CutefishOS, CuteOS, CyberOS, dahlia, DarkOs, Darwin, Debian, Deepin,
                                DesaOS, Devuan, DietPi, digital UNIX, DracOS, DragonFly, Drauger,
                                Droidian, Elementary, Elive, EncryptOS, EndeavourOS, Endless, Enso,
                                EuroLinux, EvolutionOS, eweOS, Exherbo, Exodia Predator OS, Fedora,
                                FemboyOS, Feren, Finnix, Floflis, FreeBSD, FreeMiNT, Frugalware,
                                Funtoo, GalliumOS, Garuda, Gentoo, GhostBSD, glaucus, gNewSense,
                                GNOME, GNU, GoboLinux, GrapheneOS, Grombyang, Guix, Haiku, HamoniKR,
                                HarDClanZ, Hash, Huayra, Hybrid, HydroOS, Hyperbola, iglunix,
                                instantOS, Interix, IRIX, Ironclad, Itc, januslinux, Kaisen, Kali,
                                KaOS, KDE, Kibojoe, Kogaion, Korora, KrassOS, KSLinux, Kubuntu,
                                LainOS, LangitKetujuh, LaxerOS, LEDE, LibreELEC, Linspire, Linux,
                                Linux Lite, Linux Mint, Linux Mint Old, Live Raizo, LMDE, Lubuntu,
                                Lunar, mac, Mageia, MagpieOS, MainsailOS, Mandriva, Manjaro, MassOS,
                                MatuusOS, Maui, Meowix, Mer, Minix, MIRACLE LINUX, MX, Namib, NekOS,
                                Neptune, NetBSD, Netrunner, Nitrux, NixOS, Nobara, NomadBSD,
                                Nurunner, NuTyX, Obarun, OBRevenge, OmniOS, Open Source Media
                                Center, OpenBSD, openEuler, OpenIndiana, openKylin, openmamba,
                                OpenMandriva, OpenStage, openSUSE, openSUSE Leap, openSUSE
                                Tumbleweed, OPNsense, Oracle, orchid, OS Elbrus, PacBSD, Panwah,
                                Parabola, parch, Pardus, Parrot, Parsix, PCBSD, PCLinuxOS, pearOS,
                                Pengwin, Pentoo, Peppermint, Peropesis, phyOS, PikaOS, Pisi, PNM
                                Linux, Pop!_OS, Porteus, PostMarketOS, Profelis SambaBOX, Proxmox,
                                PuffOS, Puppy, PureOS, Q4OS, Qubes, Qubyt, Quibian, Radix, Raspbian,
                                ravynOS, Reborn OS, Red Star, Redcore, Redhat, Refracted Devuan,
                                Regata, Regolith, RhaymOS, rocky, Rosa, Sabayon, sabotage, Sailfish,
                                SalentOS, Salient OS, Salix, Sasanqua, Scientific, semc, Septor,
                                Serene, SharkLinux, ShastraOS, Siduction, SkiffOS, Slackel,
                                Slackware, SliTaz, SmartOS, Soda, Solus, Source Mage, Sparky, Star,
                                SteamOS, Stock Linux, Sulin, SunOS, SwagArch, t2, Tails, TeArch,
                                TorizonCore, Trisquel, Twister, Ubuntu, Ubuntu Budgie, Ubuntu
                                Cinnamon, Ubuntu Kylin, Ubuntu MATE, Ubuntu Studio, Ubuntu Sway,
                                Ubuntu Touch, Ubuntu-GNOME, ubuntu_old02, Ultramarine Linux,
                                unicodearch, Univalent, Univention, Uos, UrukOS, uwuntu, Vanilla,
                                Venom, VNux, Void, VzLinux, wii-linux-ngx, Windows, Windows 10,
                                Windows 11, Windows95, Wrt, Xenia, Xenia2, XFerience, Xray_OS,
                                Xubuntu, yiffOS, Zorin have ascii logos.

                                NOTE: arch, dragonfly, Fedora, LangitKetujuh, nixos, redhat, Ubuntu
                                have 'old' logo variants, use {distro}_old to use them.

                                NOTE: alpine, android, arch, arcolinux, artix, CalinixOS, centos,
                                cleanjaro, crux, debian, dragonfly, elementary, endeavouros, fedora,
                                freebsd, garuda, gentoo, guix, haiku, hyperbola, kali, Linux,
                                linuxlite, linuxmint, mac, mageia, MainsailOS, manjaro, mx, netbsd,
                                nixos, openbsd, opensuse, orchid, parabola, popos, postmarketos,
                                pureos, Raspbian, rocky, slackware, sunos, ubuntu, venom, void have
                                'small' logo variants, use {distro}_small to use them.

                                NOTE: Fedora has immutable spins with unique logos (except Onyx).

                                NOTE: Change this to Silverblue, Kinoite, Sericea, or CoreOS to use
                                the spins.

    --ascii_bold on/off         Whether or not to bold the ascii logo.
    -L, --logo                  Hide the info text and only show the ascii logo.

IMAGE:
    --loop                      Redraw the image constantly until Ctrl+C is used. This fixes issues
                                in some terminals emulators when using image mode.
    --size 00px | --size 00%    How to size the image.
                                Possible values: auto, 00px, 00%, none
    --catimg_size 1/2           Change the resolution of catimg.
    --crop_mode mode            Which crop mode to use
                                Takes the values: normal, fit, fill
    --crop_offset value         Change the crop offset for normal mode.
                                Possible values: northwest, north, northeast,
                                west, center, east, southwest, south, southeast

    --xoffset px                How close the image will be to the left edge of the
                                window. This only works with w3m.
    --yoffset px                How close the image will be to the top edge of the
                                window. This only works with w3m.
    --bg_color color            Background color to display behind transparent image.
                                This only works with w3m.
    --gap num                   Gap between image and text.

                                NOTE: --gap can take a negative value which will move the text
                                closer to the left side.

    --clean                     Delete cached files and thumbnails.

OTHER:
    --config /path/to/config    Specify a path to a custom config file
    --config none               Launch the script without a config file
    --no_config                 Don't create the user config file.
    --print_config              Print the default config file to stdout.
    --stdout=on                 Turn off all colors and disables any ASCII/image backend.
    --stdout=off                Enable the colored output and ASCII/image backend
    --stdout=auto               Let the program decide basing on the output type (default behavior)
    --stdout                    Equivalent to '--stdout=on', for backward compatibility
    --help                      Print this text and exit
    --version                   Show neofetch version
    -v                          Display error messages.
    -vv                         Display a verbose log for error reporting.

DEVELOPER:
    --gen-man                   Generate a manpage for Neofetch in your PWD. (Requires GNU help2man)


Report bugs to https://github.com/dylanaraps/neofetch/issues

"
exit 1
}

get_args() {
    # Check the commandline flags early for '--config'.
    [[ "$*" != *--config* && "$*" != *--no_config* ]] && get_user_config

    while [[ "$1" ]]; do
        case $1 in
            # Info
            "--title_fqdn") title_fqdn="$2" ;;
            "--package_managers") package_managers="$2" ;;
            "--package_separate") package_separate="$2" ;;
            "--package_minimal") package_minimal="1" ;;
            "--os_arch") os_arch="$2" ;;
            "--cpu_cores") cpu_cores="$2" ;;
            "--cpu_speed") cpu_speed="$2" ;;
            "--speed_type") speed_type="$2" ;;
            "--speed_shorthand") speed_shorthand="$2" ;;
            "--distro_shorthand") distro_shorthand="$2" ;;
            "--kernel_shorthand") kernel_shorthand="$2" ;;
            "--uptime_shorthand") uptime_shorthand="$2" ;;
            "--cpu_brand") cpu_brand="$2" ;;
            "--gpu_brand") gpu_brand="$2" ;;
            "--gpu_type") gpu_type="$2" ;;
            "--refresh_rate") refresh_rate="$2" ;;
            "--de_version") de_version="$2" ;;
            "--gtk_shorthand") gtk_shorthand="$2" ;;
            "--gtk2") gtk2="$2" ;;
            "--gtk3") gtk3="$2" ;;
            "--qt")     qt="$2" ;;
            "--shell_path") shell_path="$2" ;;
            "--shell_version") shell_version="$2" ;;
            "--editor_path") editor_path="$2" ;;
            "--editor_version") editor_version="$2" ;;
            "--ip_host") public_ip_host="$2" ;;
            "--ip_timeout") public_ip_timeout="$2" ;;
            "--ip_interface")
                unset local_ip_interface
                for arg in "$@"; do
                    case "$arg" in
                        "--ip_interface") ;;
                        "-"*) break ;;
                        *) local_ip_interface+=("$arg") ;;
                    esac
                done
            ;;

            "--song_format") song_format="$2" ;;
            "--song_shorthand") song_shorthand="$2" ;;
            "--music_player") music_player="$2" ;;
            "--memory_percent") memory_percent="$2" ;;
            "--memory_unit") memory_unit="$2" ;;
            "--memory_precision") mem_precision="$2" ;;
            "--cpu_temp")
                cpu_temp="$2"
                [[ "$cpu_temp" == "on" ]] && cpu_temp="C"
            ;;

            "--disk_subtitle") disk_subtitle="$2" ;;
            "--disk_percent")  disk_percent="$2" ;;
            "--disk_show")
                unset disk_show
                for arg in "$@"; do
                    case $arg in
                        "--disk_show") ;;
                        "-"*) break ;;
                        *) disk_show+=("$arg") ;;
                    esac
                done
            ;;

            "--disable")
                for func in "$@"; do
                    case $func in
                        "--disable") continue ;;
                        "-"*) break ;;
                        *)
                            ((bash_version >= 4)) && func="${func,,}"
                            unset -f "get_$func"
                        ;;
                    esac
                done
            ;;

            # Text Colors
            "--colors")
                unset colors
                for arg in "$2" "$3" "$4" "$5" "$6" "$7"; do
                    case $arg in
                        "-"*) break ;;
                        *) colors+=("$arg") ;;
                    esac
                done
                colors+=(7 7 7 7 7 7)
            ;;

            # Text Formatting
            "--underline") underline_enabled="$2" ;;
            "--underline_char") underline_char="$2" ;;
            "--bold") bold="$2" ;;
            "--separator") separator="$2" ;;

            # Color Blocks
            "--color_blocks") color_blocks="$2" ;;
            "--block_range") block_range=("$2" "$3") ;;
            "--block_width") block_width="$2" ;;
            "--block_height") block_height="$2" ;;
            "--col_offset") col_offset="$2" ;;

            # Bars
            "--bar_char")
                bar_char_elapsed="$2"
                bar_char_total="$3"
            ;;

            "--bar_border") bar_border="$2" ;;
            "--bar_length") bar_length="$2" ;;
            "--bar_colors")
                bar_color_elapsed="$2"
                bar_color_total="$3"
            ;;

            "--memory_display") memory_display="$2" ;;
            "--battery_display") battery_display="$2" ;;
            "--disk_display") disk_display="$2" ;;

            # Image backend
            "--backend") image_backend="$2" ;;
            "--source") image_source="$2" ;;
            "--ascii" | "--caca" | "--catimg" | "--chafa" | "--jp2a" | "--iterm2" | "--off" |\
            "--pot" | "--pixterm" | "--sixel" | "--termpix" | "--tycat" | "--w3m" | "--kitty" |\
            "--ueberzug" | "--viu")
                image_backend="${1/--}"
                case $2 in
                    "-"* | "") ;;
                    *) image_source="$2" ;;
                esac
            ;;

            # Image options
            "--loop") image_loop="on" ;;
            "--image_size" | "--size") image_size="$2" ;;
            "--catimg_size") catimg_size="$2" ;;
            "--crop_mode") crop_mode="$2" ;;
            "--crop_offset") crop_offset="$2" ;;
            "--xoffset") xoffset="$2" ;;
            "--yoffset") yoffset="$2" ;;
            "--background_color" | "--bg_color") background_color="$2" ;;
            "--gap") gap="$2" ;;
            "--clean")
                [[ -d "$thumbnail_dir" ]] && rm -rf "$thumbnail_dir"
                rm -rf "$cache_dir/neofetch/"
                exit
            ;;

            "--ascii_colors")
                unset ascii_colors
                for arg in "$2" "$3" "$4" "$5" "$6" "$7"; do
                    case $arg in
                        "-"*) break ;;
                        *) ascii_colors+=("$arg")
                    esac
                done
                ascii_colors+=(7 7 7 7 7 7)
            ;;

            "--ascii_distro")
                image_backend="ascii"
                ascii_distro="$2"
            ;;

            "--ascii_bold") ascii_bold="$2" ;;
            "--logo" | "-L")
                image_backend="ascii"
                print_info() { printf '\n'; }
            ;;

            # Other
            "--config")
                case $2 in
                    "none" | "off" | "") ;;
                    *)
                        config_file="$(get_full_path "$2")"
                        get_user_config
                    ;;
                esac
            ;;
            "--no_config") no_config="on" ;;
            "--stdout") stdout="on" ;;
            "--stdout=on") stdout="on" ;;
            "--stdout=off") stdout="off" ;;
            "--stdout=auto") stdout="auto" ;;
            "-v") verbose="on" ;;
            "--print_config") printf '%s\n' "$config"; exit ;;
            "-vv") set -x; verbose="on" ;;
            "--help") usage ;;
            "--version")
                printf '%s\n' "Neofetch $version"
                exit 1
            ;;
            "--gen-man")
                help2man -n "A fast, highly customizable system info script" \
                          -N ./neofetch -o neofetch.1
                exit 1
            ;;

            "--json")
                json="on"
                unset -f get_title get_cols get_underline

                printf '{\n'
                print_info 2>/dev/null
                printf '    %s\n' "\"Version\": \"${version}\""
                printf '}\n'
                exit
            ;;

            "--travis")
                print_info() {
                    info title
                    info underline

                    info "OS" distro
                    info "Host" model
                    info "Kernel" kernel
                    info "Uptime" uptime
                    info "Packages" packages
                    info "Shell" shell
                    info "Resolution" resolution
                    info "DE" de
                    info "WM" wm
                    info "WM Theme" wm_theme
                    info "Theme" theme
                    info "Icons" icons
                    info "Terminal" term
                    info "Terminal Font" term_font
                    info "CPU" cpu
                    info "GPU" gpu
                    info "GPU Driver" gpu_driver
                    info "Memory" memory
                    info "Network" network
                    info "Bluetooth" bluetooth
                    info "BIOS" bios

                    info "Disk" disk
                    info "Battery" battery
                    info "Power Adapter" power_adapter
                    info "Font" font
                    info "Song" song
                    info "Local IP" local_ip
                    info "Public IP" public_ip
                    info "Users" users

                    info cols

                    # Testing.
                    prin "prin"
                    prin "prin" "prin"

                    # Testing no subtitles.
                    info uptime
                    info disk
                }

                refresh_rate="on"
                shell_version="on"
                memory_display="infobar"
                disk_display="infobar"
                cpu_temp="C"

                # Known implicit unused variables.
                mpc_args=()
                printf '%s\n' "$kernel $icons $font $cursor $battery $locale ${mpc_args[*]}"
            ;;
        esac

        shift
    done
}

get_simple() {
    while [[ "$1" ]]; do
        [[ "$(type -t "get_$1")" == "function" ]] && {
            get_distro
            stdout
            simple=1
            info "$1" "$1"
        }
        shift
    done
    ((simple)) && exit
}

old_functions() {
    # Removed functions for backwards compatibility.
    get_line_break() { :; }
    get_cpu_usage() { :; }
}

get_distro_ascii() {
    # This function gets the distro ascii art and colors.
    #
    # $ascii_distro is the same as $distro.
            set_colors 6 6 7 1
            read -rd '' ascii_data <<'EOF'
${c1}                   -`
                  .o+`
                 `ooo/
                `+oooo:
               `+oooooo:
               -+oooooo+:
             `/:-:++oooo+:
            `/++++/+++++++:
           `/++++++++++++++:
          `/+++o${c2}oooooooo${c1}oooo/`
${c2}         ${c1}./${c2}ooosssso++osssssso${c1}+`
${c2}        .oossssso-````/ossssss+`
       -osssssso.      :ssssssso.
      :osssssss/        osssso+++.
     /ossssssss/        +ssssooo/-
   `/ossssso+/:-        -:/+osssso+-
  `+sso+:-`                 `.-/+oso:
 `++:.                           `-/+/
 .`                                 `/
EOF

    # Overwrite distro colors if '$ascii_colors' doesn't
    # equal 'distro'.
    [[ ${ascii_colors[0]} != distro ]] && {
        color_text=off
        set_colors "${ascii_colors[@]}"
    }
}

main() {
    cache_uname
    get_os
    get_cache_dir

    # Load default config.
    eval "$config"

    get_args "$@"
    [[ $verbose != on ]] && exec 2>/dev/null
    get_simple "$@"
    get_distro
    get_bold
    get_distro_ascii

    # check if the output is a interactive terminal
    [[ $stdout == auto ]] && {
        [[ -t 1 ]] && stdout=off || stdout=on
    }

    [[ $stdout == on ]] && stdout

    # Minix doesn't support these sequences.
    [[ $TERM != minix && $stdout != on ]] && {
        # If the script exits for any reason, unhide the cursor.
        trap 'printf "\e[?25h\e[?7h"' EXIT

        # Hide the cursor and disable line wrap.
        printf '\e[?25l\e[?7l'
    }

    image_backend
    old_functions
    print_info
    dynamic_prompt

    # w3m-img: Draw the image a second time to fix
    # rendering issues in specific terminal emulators.
    [[ $image_backend == *w3m* ]] && display_image
    [[ $image_backend == *ueberzug* ]] && display_image

    # Add neofetch info to verbose output.
    err "Neofetch command: $0 $*"
    err "Neofetch version: $version"

    [[ $verbose == on ]] && printf '%b\033[m' "$err" >&2

    # If `--loop` was used, constantly redraw the image.
    while [[ $image_loop == on && $image_backend == w3m ]]; do
        display_image
        sleep 1
    done

    return 0
}

get_ascii_distro_name() {
    get_distro
    echo "$ascii_distro"
}

get_print_ascii() {
    cache_uname
    get_os
    get_distro
    get_bold
    get_distro_ascii
    echo "$ascii_data"
}

main "$@"
